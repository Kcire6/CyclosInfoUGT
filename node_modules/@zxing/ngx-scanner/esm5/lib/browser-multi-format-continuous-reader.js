/// <reference path="./image-capture.d.ts" />
import { __awaiter, __extends, __generator, __values } from "tslib";
import { BrowserMultiFormatReader, ChecksumException, FormatException, NotFoundException } from '@zxing/library';
import { BehaviorSubject } from 'rxjs';
/**
 * Based on zxing-typescript BrowserCodeReader
 */
var BrowserMultiFormatContinuousReader = /** @class */ (function (_super) {
    __extends(BrowserMultiFormatContinuousReader, _super);
    function BrowserMultiFormatContinuousReader() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        /**
         * Says if there's a torch available for the current device.
         */
        _this._isTorchAvailable = new BehaviorSubject(undefined);
        return _this;
    }
    Object.defineProperty(BrowserMultiFormatContinuousReader.prototype, "isTorchAvailable", {
        /**
         * Exposes _tochAvailable .
         */
        get: function () {
            return this._isTorchAvailable.asObservable();
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Starts the decoding from the current or a new video element.
     *
     * @param callbackFn The callback to be executed after every scan attempt
     * @param deviceId The device's to be used Id
     * @param videoSource A new video element
     */
    BrowserMultiFormatContinuousReader.prototype.continuousDecodeFromInputVideoDevice = function (deviceId, videoSource) {
        var _this = this;
        this.reset();
        // Keeps the deviceId between scanner resets.
        if (typeof deviceId !== 'undefined') {
            this.deviceId = deviceId;
        }
        if (typeof navigator === 'undefined') {
            return;
        }
        var scan$ = new BehaviorSubject({});
        try {
            // this.decodeFromInputVideoDeviceContinuously(deviceId, videoSource, (result, error) => scan$.next({ result, error }));
            this.getStreamForDevice({ deviceId: deviceId })
                .then(function (stream) { return _this.attachStreamToVideoAndCheckTorch(stream, videoSource); })
                .then(function (videoElement) { return _this.decodeOnSubject(scan$, videoElement, _this.timeBetweenScansMillis); });
        }
        catch (e) {
            scan$.error(e);
        }
        this._setScanStream(scan$);
        // @todo Find a way to emit a complete event on the scan stream once it's finished.
        return scan$.asObservable();
    };
    /**
     * Gets the media stream for certain device.
     * Falls back to any available device if no `deviceId` is defined.
     */
    BrowserMultiFormatContinuousReader.prototype.getStreamForDevice = function (_a) {
        var deviceId = _a.deviceId;
        return __awaiter(this, void 0, void 0, function () {
            var constraints, stream;
            return __generator(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        constraints = this.getUserMediaConstraints(deviceId);
                        return [4 /*yield*/, navigator.mediaDevices.getUserMedia(constraints)];
                    case 1:
                        stream = _b.sent();
                        return [2 /*return*/, stream];
                }
            });
        });
    };
    /**
     * Creates media steram constraints for certain `deviceId`.
     * Falls back to any environment available device if no `deviceId` is defined.
     */
    BrowserMultiFormatContinuousReader.prototype.getUserMediaConstraints = function (deviceId) {
        var video = typeof deviceId === 'undefined'
            ? { facingMode: { exact: 'environment' } }
            : { deviceId: { exact: deviceId } };
        var constraints = { video: video };
        return constraints;
    };
    /**
     * Enables and disables the device torch.
     */
    BrowserMultiFormatContinuousReader.prototype.setTorch = function (on) {
        if (!this._isTorchAvailable.value) {
            // compatibility not checked yet
            return;
        }
        var tracks = this.getVideoTracks(this.stream);
        if (on) {
            this.applyTorchOnTracks(tracks, true);
        }
        else {
            this.applyTorchOnTracks(tracks, false);
            // @todo check possibility to disable torch without restart
            this.restart();
        }
    };
    /**
     * Update the torch compatibility state and attachs the stream to the preview element.
     */
    BrowserMultiFormatContinuousReader.prototype.attachStreamToVideoAndCheckTorch = function (stream, videoSource) {
        this.updateTorchCompatibility(stream);
        return this.attachStreamToVideo(stream, videoSource);
    };
    /**
     * Checks if the stream supports torch control.
     *
     * @param stream The media stream used to check.
     */
    BrowserMultiFormatContinuousReader.prototype.updateTorchCompatibility = function (stream) {
        return __awaiter(this, void 0, void 0, function () {
            var tracks, tracks_1, tracks_1_1, track, e_1_1;
            var e_1, _a;
            return __generator(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        tracks = this.getVideoTracks(stream);
                        _b.label = 1;
                    case 1:
                        _b.trys.push([1, 6, 7, 8]);
                        tracks_1 = __values(tracks), tracks_1_1 = tracks_1.next();
                        _b.label = 2;
                    case 2:
                        if (!!tracks_1_1.done) return [3 /*break*/, 5];
                        track = tracks_1_1.value;
                        return [4 /*yield*/, this.isTorchCompatible(track)];
                    case 3:
                        if (_b.sent()) {
                            this._isTorchAvailable.next(true);
                            return [3 /*break*/, 5];
                        }
                        _b.label = 4;
                    case 4:
                        tracks_1_1 = tracks_1.next();
                        return [3 /*break*/, 2];
                    case 5: return [3 /*break*/, 8];
                    case 6:
                        e_1_1 = _b.sent();
                        e_1 = { error: e_1_1 };
                        return [3 /*break*/, 8];
                    case 7:
                        try {
                            if (tracks_1_1 && !tracks_1_1.done && (_a = tracks_1.return)) _a.call(tracks_1);
                        }
                        finally { if (e_1) throw e_1.error; }
                        return [7 /*endfinally*/];
                    case 8: return [2 /*return*/];
                }
            });
        });
    };
    /**
     *
     * @param stream The video stream where the tracks gonna be extracted from.
     */
    BrowserMultiFormatContinuousReader.prototype.getVideoTracks = function (stream) {
        var tracks = [];
        try {
            tracks = stream.getVideoTracks();
        }
        finally {
            return tracks || [];
        }
    };
    /**
     *
     * @param track The media stream track that will be checked for compatibility.
     */
    BrowserMultiFormatContinuousReader.prototype.isTorchCompatible = function (track) {
        return __awaiter(this, void 0, void 0, function () {
            var compatible, imageCapture, capabilities;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        compatible = false;
                        _a.label = 1;
                    case 1:
                        _a.trys.push([1, , 3, 4]);
                        imageCapture = new ImageCapture(track);
                        return [4 /*yield*/, imageCapture.getPhotoCapabilities()];
                    case 2:
                        capabilities = _a.sent();
                        compatible = !!capabilities['torch'] || ('fillLightMode' in capabilities && capabilities.fillLightMode.length !== 0);
                        return [3 /*break*/, 4];
                    case 3: return [2 /*return*/, compatible];
                    case 4: return [2 /*return*/];
                }
            });
        });
    };
    /**
     * Apply the torch setting in all received tracks.
     */
    BrowserMultiFormatContinuousReader.prototype.applyTorchOnTracks = function (tracks, state) {
        tracks.forEach(function (track) { return track.applyConstraints({
            advanced: [{ torch: state, fillLightMode: state ? 'torch' : 'none' }]
        }); });
    };
    /**
     * Correctly sets a new scanStream value.
     */
    BrowserMultiFormatContinuousReader.prototype._setScanStream = function (scan$) {
        // cleans old stream
        this._cleanScanStream();
        // sets new stream
        this.scanStream = scan$;
    };
    /**
     * Cleans any old scan stream value.
     */
    BrowserMultiFormatContinuousReader.prototype._cleanScanStream = function () {
        if (this.scanStream && !this.scanStream.isStopped) {
            this.scanStream.complete();
        }
        this.scanStream = null;
    };
    /**
     * Decodes values in a stream with delays between scans.
     *
     * @param scan$ The subject to receive the values.
     * @param videoElement The video element the decode will be applied.
     * @param delay The delay between decode results.
     */
    BrowserMultiFormatContinuousReader.prototype.decodeOnSubject = function (scan$, videoElement, delay) {
        var _this = this;
        // stops loop
        if (scan$.isStopped) {
            return;
        }
        var result;
        try {
            result = this.decode(videoElement);
            scan$.next({ result: result });
        }
        catch (error) {
            // stream cannot stop on fails.
            if (!error ||
                // scan Failure - found nothing, no error
                error instanceof NotFoundException ||
                // scan Error - found the QR but got error on decoding
                error instanceof ChecksumException ||
                error instanceof FormatException) {
                scan$.next({ error: error });
            }
            else {
                scan$.error(error);
            }
        }
        finally {
            var timeout = !result ? 0 : delay;
            setTimeout(function () { return _this.decodeOnSubject(scan$, videoElement, delay); }, timeout);
        }
    };
    /**
     * Restarts the scanner.
     */
    BrowserMultiFormatContinuousReader.prototype.restart = function () {
        // reset
        // start
        return this.continuousDecodeFromInputVideoDevice(this.deviceId, this.videoElement);
    };
    return BrowserMultiFormatContinuousReader;
}(BrowserMultiFormatReader));
export { BrowserMultiFormatContinuousReader };
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiYnJvd3Nlci1tdWx0aS1mb3JtYXQtY29udGludW91cy1yZWFkZXIuanMiLCJzb3VyY2VSb290Ijoibmc6Ly9Aenhpbmcvbmd4LXNjYW5uZXIvIiwic291cmNlcyI6WyJsaWIvYnJvd3Nlci1tdWx0aS1mb3JtYXQtY29udGludW91cy1yZWFkZXIudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUEsNkNBQTZDOztBQUU3QyxPQUFPLEVBQUUsd0JBQXdCLEVBQUUsaUJBQWlCLEVBQUUsZUFBZSxFQUFFLGlCQUFpQixFQUFVLE1BQU0sZ0JBQWdCLENBQUM7QUFDekgsT0FBTyxFQUFFLGVBQWUsRUFBYyxNQUFNLE1BQU0sQ0FBQztBQUduRDs7R0FFRztBQUNIO0lBQXdELHNEQUF3QjtJQUFoRjtRQUFBLHFFQXVQQztRQTlPQzs7V0FFRztRQUNLLHVCQUFpQixHQUFHLElBQUksZUFBZSxDQUFVLFNBQVMsQ0FBQyxDQUFDOztJQTJPdEUsQ0FBQztJQWxQQyxzQkFBVyxnRUFBZ0I7UUFIM0I7O1dBRUc7YUFDSDtZQUNFLE9BQU8sSUFBSSxDQUFDLGlCQUFpQixDQUFDLFlBQVksRUFBRSxDQUFDO1FBQy9DLENBQUM7OztPQUFBO0lBaUJEOzs7Ozs7T0FNRztJQUNJLGlGQUFvQyxHQUEzQyxVQUNFLFFBQWlCLEVBQ2pCLFdBQThCO1FBRmhDLGlCQWdDQztRQTNCQyxJQUFJLENBQUMsS0FBSyxFQUFFLENBQUM7UUFFYiw2Q0FBNkM7UUFDN0MsSUFBSSxPQUFPLFFBQVEsS0FBSyxXQUFXLEVBQUU7WUFDbkMsSUFBSSxDQUFDLFFBQVEsR0FBRyxRQUFRLENBQUM7U0FDMUI7UUFFRCxJQUFJLE9BQU8sU0FBUyxLQUFLLFdBQVcsRUFBRTtZQUNwQyxPQUFPO1NBQ1I7UUFFRCxJQUFNLEtBQUssR0FBRyxJQUFJLGVBQWUsQ0FBaUIsRUFBRSxDQUFDLENBQUM7UUFFdEQsSUFBSTtZQUNGLHdIQUF3SDtZQUN4SCxJQUFJLENBQUMsa0JBQWtCLENBQUMsRUFBRSxRQUFRLFVBQUEs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S0FBSyxDQUFDLEVBQWhELENBQWdELEVBQUUsT0FBTyxDQUFDLENBQUM7U0FDN0U7SUFDSCxDQUFDO0lBRUQ7O09BRUc7SUFDSyxvREFBTyxHQUFmO1FBQ0UsUUFBUTtRQUNSLFFBQVE7UUFDUixPQUFPLElBQUksQ0FBQyxvQ0FBb0MsQ0FBQyxJQUFJLENBQUMsUUFBUSxFQUFFLElBQUksQ0FBQyxZQUFZLENBQUMsQ0FBQztJQUNyRixDQUFDO0lBRUgseUNBQUM7QUFBRCxDQUFDLEFBdlBELENBQXdELHdCQUF3QixHQXVQL0UiLCJzb3VyY2VzQ29udGVudCI6WyIvLy8gPHJlZmVyZW5jZSBwYXRoPVwiLi9pbWFnZS1jYXB0dXJlLmQudHNcIiAvPlxyXG5cclxuaW1wb3J0IHsgQnJvd3Nlck11bHRpRm9ybWF0UmVhZGVyLCBDaGVja3N1bUV4Y2VwdGlvbiwgRm9ybWF0RXhjZXB0aW9uLCBOb3RGb3VuZEV4Y2VwdGlvbiwgUmVzdWx0IH0gZnJvbSAnQHp4aW5nL2xpYnJhcnknO1xyXG5pbXBvcnQgeyBCZWhhdmlvclN1YmplY3QsIE9ic2VydmFibGUgfSBmcm9tICdyeGpzJztcclxuaW1wb3J0IHsgUmVzdWx0QW5kRXJyb3IgfSBmcm9tICcuL1Jlc3VsdEFuZEVycm9yJztcclxuXHJcbi8qKlxyXG4gKiBCYXNlZCBvbiB6eGluZy10eXBlc2NyaXB0IEJyb3dzZXJDb2RlUmVhZGVyXHJcbiAqL1xyXG5leHBvcnQgY2xhc3MgQnJvd3Nlck11bHRpRm9ybWF0Q29udGludW91c1JlYWRlciBleHRlbmRzIEJyb3dzZXJNdWx0aUZvcm1hdFJlYWRlciB7XHJcblxyXG4gIC8qKlxyXG4gICAqIEV4cG9zZXMgX3RvY2hBdmFpbGFibGUgLlxyXG4gICAqL1xyXG4gIHB1YmxpYyBnZXQgaXNUb3JjaEF2YWlsYWJsZSgpOiBPYnNlcnZhYmxlPGJvb2xlYW4+IHtcclxuICAgIHJldHVybiB0aGlzLl9pc1RvcmNoQXZhaWxhYmxlLmFzT2JzZXJ2YWJsZSgpO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogU2F5cyBpZiB0aGVyZSdzIGEgdG9yY2ggYXZhaWxhYmxlIGZvciB0aGUgY3VycmVudCBkZXZpY2UuXHJcbiAgICovXHJcbiAgcHJpdmF0ZSBfaXNUb3JjaEF2YWlsYWJsZSA9IG5ldyBCZWhhdmlvclN1YmplY3Q8Ym9vbGVhbj4odW5kZWZpbmVkKTtcclxuXHJcbiAgLyoqXHJcbiAgICogVGhlIGRldmljZSBpZCBvZiB0aGUgY3VycmVudCBtZWRpYSBkZXZpY2UuXHJcbiAgICovXHJcbiAgcHJpdmF0ZSBkZXZpY2VJZDogc3RyaW5nO1xyXG5cclxuICAvKipcclxuICAgKiBJZiB0aGVyZSdzIHNvbWUgc2NhbiBzdHJlYW0gb3BlbiwgaXQgc2hhbCBiZSBoZXJlLlxyXG4gICAqL1xyXG4gIHByaXZhdGUgc2NhblN0cmVhbTogQmVoYXZpb3JTdWJqZWN0PFJlc3VsdEFuZEVycm9yPjtcclxuXHJcbiAgLyoqXHJcbiAgICogU3RhcnRzIHRoZSBkZWNvZGluZyBmcm9tIHRoZSBjdXJyZW50IG9yIGEgbmV3IHZpZGVvIGVsZW1lbnQuXHJcbiAgICpcclxuICAgKiBAcGFyYW0gY2FsbGJhY2tGbiBUaGUgY2FsbGJhY2sgdG8gYmUgZXhlY3V0ZWQgYWZ0ZXIgZXZlcnkgc2NhbiBhdHRlbXB0XHJcbiAgICogQHBhcmFtIGRldmljZUlkIFRoZSBkZXZpY2UncyB0byBiZSB1c2VkIElkXHJcbiAgICogQHBhcmFtIHZpZGVvU291cmNlIEEgbmV3IHZpZGVvIGVsZW1lbnRcclxuICAgKi9cclxuICBwdWJsaWMgY29udGludW91c0RlY29kZUZyb21JbnB1dFZpZGVvRGV2aWNlKFxyXG4gICAgZGV2aWNlSWQ/OiBzdHJpbmcsXHJcbiAgICB2aWRlb1NvdXJjZT86IEhUTUxWaWRlb0VsZW1lbnRcclxuICApOiBPYnNlcnZhYmxlPFJlc3VsdEFuZEVycm9yPiB7XHJcblxyXG4gICAgdGhpcy5yZXNldCgpO1xyXG5cclxuICAgIC8vIEtlZXBzIHRoZSBkZXZpY2VJZCBiZXR3ZWVuIHNjYW5uZXIgcmVzZXRzLlxyXG4gICAgaWYgKHR5cGVvZiBkZXZpY2VJZCAhPT0gJ3VuZGVmaW5lZCcpIHtcclxuICAgICAgdGhpcy5kZXZpY2VJZCA9IGRldmljZUlkO1xyXG4gICAgfVxyXG5cclxuICAgIGlmICh0eXBlb2YgbmF2aWdhdG9yID09PSAndW5kZWZpbmVkJykge1xyXG4gICAgICByZXR1cm47XHJcbiAgICB9XHJcblxyXG4gICAgY29uc3Qgc2NhbiQgPSBuZXcgQmVoYXZpb3JTdWJqZWN0PFJlc3VsdEFuZEVycm9yPih7fSk7XHJcblxyXG4gICAgdHJ5IHtcclxuICAgICAgLy8gdGhpcy5kZWNvZGVGcm9tSW5wdXRWaWRlb0RldmljZUNvbnRpbnVvdXNseShkZXZpY2VJZCwgdmlkZW9Tb3VyY2UsIChyZXN1bHQsIGVycm9yKSA9PiBzY2FuJC5uZXh0KHsgcmVzdWx0LCBlcnJvciB9KSk7XHJcbiAgICAgIHRoaXMuZ2V0U3RyZWFtRm9yRGV2aWNlKHsgZGV2aWNlSWQgfSlcclxuICAgICAgICAudGhlbihzdHJlYW0gPT4gdGhpcy5hdHRhY2hTdHJlYW1Ub1ZpZGVvQW5kQ2hlY2tUb3JjaChzdHJlYW0sIHZpZGVvU291cmNlKSlcclxuICAgICAgICAudGhlbih2aWRlb0VsZW1lbnQgPT4gdGhpcy5kZWNvZGVPblN1YmplY3Qoc2NhbiQsIHZpZGVvRWxlbWVudCwgdGhpcy50aW1lQmV0d2VlblNjYW5zTWlsbGlzKSk7XHJcbiAgICB9IGNhdGNoIChlKSB7XHJcbiAgICAgIHNjYW4kLmVycm9yKGUpO1xyXG4gICAgfVxyXG5cclxuICAgIHRoaXMuX3NldFNjYW5TdHJlYW0oc2NhbiQpO1xyXG5cclxuICAgIC8vIEB0b2RvIEZpbmQgYSB3YXkgdG8gZW1pdCBhIGNvbXBsZXRlIGV2ZW50IG9uIHRoZSBzY2FuIHN0cmVhbSBvbmNlIGl0J3MgZmluaXNoZWQuXHJcblxyXG4gICAgcmV0dXJuIHNjYW4kLmFzT2JzZXJ2YWJsZSgpO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogR2V0cyB0aGUgbWVkaWEgc3RyZWFtIGZvciBjZXJ0YWluIGRldmljZS5cclxuICAgKiBGYWxscyBiYWNrIHRvIGFueSBhdmFpbGFibGUgZGV2aWNlIGlmIG5vIGBkZXZpY2VJZGAgaXMgZGVmaW5lZC5cclxuICAgKi9cclxuICBwdWJsaWMgYXN5bmMgZ2V0U3RyZWFtRm9yRGV2aWNlKHsgZGV2aWNlSWQgfTogUGFydGlhbDxNZWRpYURldmljZUluZm8+KTogUHJvbWlzZTxNZWRpYVN0cmVhbT4ge1xyXG4gICAgY29uc3QgY29uc3RyYWludHMgPSB0aGlzLmdldFVzZXJNZWRpYUNvbnN0cmFpbnRzKGRldmljZUlkKTtcclxuICAgIGNvbnN0IHN0cmVhbSA9IGF3YWl0IG5hdmlnYXRvci5tZWRpYURldmljZXMuZ2V0VXNlck1lZGlhKGNvbnN0cmFpbnRzKTtcclxuICAgIHJldHVybiBzdHJlYW07XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBDcmVhdGVzIG1lZGlhIHN0ZXJhbSBjb25zdHJhaW50cyBmb3IgY2VydGFpbiBgZGV2aWNlSWRgLlxyXG4gICAqIEZhbGxzIGJhY2sgdG8gYW55IGVudmlyb25tZW50IGF2YWlsYWJsZSBkZXZpY2UgaWYgbm8gYGRldmljZUlkYCBpcyBkZWZpbmVkLlxyXG4gICAqL1xyXG4gIHB1YmxpYyBnZXRVc2VyTWVkaWFDb25zdHJhaW50cyhkZXZpY2VJZDogc3RyaW5nKTogTWVkaWFTdHJlYW1Db25zdHJhaW50cyB7XHJcblxyXG4gICAgY29uc3QgdmlkZW8gPSB0eXBlb2YgZGV2aWNlSWQgPT09ICd1bmRlZmluZWQnXHJcbiAgICAgID8geyBmYWNpbmdNb2RlOiB7IGV4YWN0OiAnZW52aXJvbm1lbnQnIH0gfVxyXG4gICAgICA6IHsgZGV2aWNlSWQ6IHsgZXhhY3Q6IGRldmljZUlkIH0gfTtcclxuXHJcbiAgICBjb25zdCBjb25zdHJhaW50czogTWVkaWFTdHJlYW1Db25zdHJhaW50cyA9IHsgdmlkZW8gfTtcclxuXHJcbiAgICByZXR1cm4gY29uc3RyYWludHM7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBFbmFibGVzIGFuZCBkaXNhYmxlcyB0aGUgZGV2aWNlIHRvcmNoLlxyXG4gICAqL1xyXG4gIHB1YmxpYyBzZXRUb3JjaChvbjogYm9vbGVhbik6IHZvaWQge1xyXG5cclxuICAgIGlmICghdGhpcy5faXNUb3JjaEF2YWlsYWJsZS52YWx1ZSkge1xyXG4gICAgICAvLyBjb21wYXRpYmlsaXR5IG5vdCBjaGVja2VkIHlldFxyXG4gICAgICByZXR1cm47XHJcbiAgICB9XHJcblxyXG4gICAgY29uc3QgdHJhY2tzID0gdGhpcy5nZXRWaWRlb1RyYWNrcyh0aGlzLnN0cmVhbSk7XHJcblxyXG4gICAgaWYgKG9uKSB7XHJcbiAgICAgIHRoaXMuYXBwbHlUb3JjaE9uVHJhY2tzKHRyYWNrcywgdHJ1ZSk7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICB0aGlzLmFwcGx5VG9yY2hPblRyYWNrcyh0cmFja3MsIGZhbHNlKTtcclxuICAgICAgLy8gQHRvZG8gY2hlY2sgcG9zc2liaWxpdHkgdG8gZGlzYWJsZSB0b3JjaCB3aXRob3V0IHJlc3RhcnRcclxuICAgICAgdGhpcy5yZXN0YXJ0KCk7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBVcGRhdGUgdGhlIHRvcmNoIGNvbXBhdGliaWxpdHkgc3RhdGUgYW5kIGF0dGFjaHMgdGhlIHN0cmVhbSB0byB0aGUgcHJldmlldyBlbGVtZW50LlxyXG4gICAqL1xyXG4gIHByaXZhdGUgYXR0YWNoU3RyZWFtVG9WaWRlb0FuZENoZWNrVG9yY2goc3RyZWFtOiBNZWRpYVN0cmVhbSwgdmlkZW9Tb3VyY2U6IEhUTUxWaWRlb0VsZW1lbnQpOiBQcm9taXNlPEhUTUxWaWRlb0VsZW1lbnQ+IHtcclxuICAgIHRoaXMudXBkYXRlVG9yY2hDb21wYXRpYmlsaXR5KHN0cmVhbSk7XHJcbiAgICByZXR1cm4gdGhpcy5hdHRhY2hTdHJlYW1Ub1ZpZGVvKHN0cmVhbSwgdmlkZW9Tb3VyY2UpO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQ2hlY2tzIGlmIHRoZSBzdHJlYW0gc3VwcG9ydHMgdG9yY2ggY29udHJvbC5cclxuICAgKlxyXG4gICAqIEBwYXJhbSBzdHJlYW0gVGhlIG1lZGlhIHN0cmVhbSB1c2VkIHRvIGNoZWNrLlxyXG4gICAqL1xyXG4gIHByaXZhdGUgYXN5bmMgdXBkYXRlVG9yY2hDb21wYXRpYmlsaXR5KHN0cmVhbTogTWVkaWFTdHJlYW0pOiBQcm9taXNlPHZvaWQ+IHtcclxuXHJcbiAgICBjb25zdCB0cmFja3MgPSB0aGlzLmdldFZpZGVvVHJhY2tzKHN0cmVhbSk7XHJcblxyXG4gICAgZm9yIChjb25zdCB0cmFjayBvZiB0cmFja3MpIHtcclxuICAgICAgaWYgKGF3YWl0IHRoaXMuaXNUb3JjaENvbXBhdGlibGUodHJhY2spKSB7XHJcbiAgICAgICAgdGhpcy5faXNUb3JjaEF2YWlsYWJsZS5uZXh0KHRydWUpO1xyXG4gICAgICAgIGJyZWFrO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKlxyXG4gICAqIEBwYXJhbSBzdHJlYW0gVGhlIHZpZGVvIHN0cmVhbSB3aGVyZSB0aGUgdHJhY2tzIGdvbm5hIGJlIGV4dHJhY3RlZCBmcm9tLlxyXG4gICAqL1xyXG4gIHByaXZhdGUgZ2V0VmlkZW9UcmFja3Moc3RyZWFtOiBNZWRpYVN0cmVhbSkge1xyXG4gICAgbGV0IHRyYWNrcyA9IFtdO1xyXG4gICAgdHJ5IHtcclxuICAgICAgdHJhY2tzID0gc3RyZWFtLmdldFZpZGVvVHJhY2tzKCk7XHJcbiAgICB9XHJcbiAgICBmaW5hbGx5IHtcclxuICAgICAgcmV0dXJuIHRyYWNrcyB8fCBbXTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqXHJcbiAgICogQHBhcmFtIHRyYWNrIFRoZSBtZWRpYSBzdHJlYW0gdHJhY2sgdGhhdCB3aWxsIGJlIGNoZWNrZWQgZm9yIGNvbXBhdGliaWxpdHkuXHJcbiAgICovXHJcbiAgcHJpdmF0ZSBhc3luYyBpc1RvcmNoQ29tcGF0aWJsZSh0cmFjazogTWVkaWFTdHJlYW1UcmFjaykge1xyXG5cclxuICAgIGxldCBjb21wYXRpYmxlID0gZmFsc2U7XHJcblxyXG4gICAgdHJ5IHtcclxuICAgICAgY29uc3QgaW1hZ2VDYXB0dXJlID0gbmV3IEltYWdlQ2FwdHVyZSh0cmFjayk7XHJcbiAgICAgIGNvbnN0IGNhcGFiaWxpdGllcyA9IGF3YWl0IGltYWdlQ2FwdHVyZS5nZXRQaG90b0NhcGFiaWxpdGllcygpO1xyXG4gICAgICBjb21wYXRpYmxlID0gISFjYXBhYmlsaXRpZXNbJ3RvcmNoJ10gfHwgKCdmaWxsTGlnaHRNb2RlJyBpbiBjYXBhYmlsaXRpZXMgJiYgY2FwYWJpbGl0aWVzLmZpbGxMaWdodE1vZGUubGVuZ3RoICE9PSAwKTtcclxuICAgIH1cclxuICAgIGZpbmFsbHkge1xyXG4gICAgICByZXR1cm4gY29tcGF0aWJsZTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEFwcGx5IHRoZSB0b3JjaCBzZXR0aW5nIGluIGFsbCByZWNlaXZlZCB0cmFja3MuXHJcbiAgICovXHJcbiAgcHJpdmF0ZSBhcHBseVRvcmNoT25UcmFja3ModHJhY2tzOiBNZWRpYVN0cmVhbVRyYWNrW10sIHN0YXRlOiBib29sZWFuKSB7XHJcbiAgICB0cmFja3MuZm9yRWFjaCh0cmFjayA9PiB0cmFjay5hcHBseUNvbnN0cmFpbnRzKHtcclxuICAgICAgYWR2YW5jZWQ6IFs8YW55PnsgdG9yY2g6IHN0YXRlLCBmaWxsTGlnaHRNb2RlOiBzdGF0ZSA/ICd0b3JjaCcgOiAnbm9uZScgfV1cclxuICAgIH0pKTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIENvcnJlY3RseSBzZXRzIGEgbmV3IHNjYW5TdHJlYW0gdmFsdWUuXHJcbiAgICovXHJcbiAgcHJpdmF0ZSBfc2V0U2NhblN0cmVhbShzY2FuJDogQmVoYXZpb3JTdWJqZWN0PFJlc3VsdEFuZEVycm9yPik6IHZvaWQge1xyXG4gICAgLy8gY2xlYW5zIG9sZCBzdHJlYW1cclxuICAgIHRoaXMuX2NsZWFuU2NhblN0cmVhbSgpO1xyXG4gICAgLy8gc2V0cyBuZXcgc3RyZWFtXHJcbiAgICB0aGlzLnNjYW5TdHJlYW0gPSBzY2FuJDtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIENsZWFucyBhbnkgb2xkIHNjYW4gc3RyZWFtIHZhbHVlLlxyXG4gICAqL1xyXG4gIHByaXZhdGUgX2NsZWFuU2NhblN0cmVhbSgpOiB2b2lkIHtcclxuXHJcbiAgICBpZiAodGhpcy5zY2FuU3RyZWFtICYmICF0aGlzLnNjYW5TdHJlYW0uaXNTdG9wcGVkKSB7XHJcbiAgICAgIHRoaXMuc2NhblN0cmVhbS5jb21wbGV0ZSgpO1xyXG4gICAgfVxyXG5cclxuICAgIHRoaXMuc2NhblN0cmVhbSA9IG51bGw7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBEZWNvZGVzIHZhbHVlcyBpbiBhIHN0cmVhbSB3aXRoIGRlbGF5cyBiZXR3ZWVuIHNjYW5zLlxyXG4gICAqXHJcbiAgICogQHBhcmFtIHNjYW4kIFRoZSBzdWJqZWN0IHRvIHJlY2VpdmUgdGhlIHZhbHVlcy5cclxuICAgKiBAcGFyYW0gdmlkZW9FbGVtZW50IFRoZSB2aWRlbyBlbGVtZW50IHRoZSBkZWNvZGUgd2lsbCBiZSBhcHBsaWVkLlxyXG4gICAqIEBwYXJhbSBkZWxheSBUaGUgZGVsYXkgYmV0d2VlbiBkZWNvZGUgcmVzdWx0cy5cclxuICAgKi9cclxuICBwcml2YXRlIGRlY29kZU9uU3ViamVjdChzY2FuJDogQmVoYXZpb3JTdWJqZWN0PFJlc3VsdEFuZEVycm9yPiwgdmlkZW9FbGVtZW50OiBIVE1MVmlkZW9FbGVtZW50LCBkZWxheTogbnVtYmVyKTogdm9pZCB7XHJcblxyXG4gICAgLy8gc3RvcHMgbG9vcFxyXG4gICAgaWYgKHNjYW4kLmlzU3RvcHBlZCkge1xyXG4gICAgICByZXR1cm47XHJcbiAgICB9XHJcblxyXG4gICAgbGV0IHJlc3VsdDogUmVzdWx0O1xyXG5cclxuICAgIHRyeSB7XHJcbiAgICAgIHJlc3VsdCA9IHRoaXMuZGVjb2RlKHZpZGVvRWxlbWVudCk7XHJcbiAgICAgIHNjYW4kLm5leHQoeyByZXN1bHQgfSk7XHJcbiAgICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgICAvLyBzdHJlYW0gY2Fubm90IHN0b3Agb24gZmFpbHMuXHJcbiAgICAgIGlmIChcclxuICAgICAgICAhZXJyb3IgfHxcclxuICAgICAgICAvLyBzY2FuIEZhaWx1cmUgLSBmb3VuZCBub3RoaW5nLCBubyBlcnJvclxyXG4gICAgICAgIGVycm9yIGluc3RhbmNlb2YgTm90Rm91bmRFeGNlcHRpb24gfHxcclxuICAgICAgICAvLyBzY2FuIEVycm9yIC0gZm91bmQgdGhlIFFSIGJ1dCBnb3QgZXJyb3Igb24gZGVjb2RpbmdcclxuICAgICAgICBlcnJvciBpbnN0YW5jZW9mIENoZWNrc3VtRXhjZXB0aW9uIHx8XHJcbiAgICAgICAgZXJyb3IgaW5zdGFuY2VvZiBGb3JtYXRFeGNlcHRpb25cclxuICAgICAgKSB7XHJcbiAgICAgICAgc2NhbiQubmV4dCh7IGVycm9yIH0pO1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIHNjYW4kLmVycm9yKGVycm9yKTtcclxuICAgICAgfVxyXG4gICAgfSBmaW5hbGx5IHtcclxuICAgICAgY29uc3QgdGltZW91dCA9ICFyZXN1bHQgPyAwIDogZGVsYXk7XHJcbiAgICAgIHNldFRpbWVvdXQoKCkgPT4gdGhpcy5kZWNvZGVPblN1YmplY3Qoc2NhbiQsIHZpZGVvRWxlbWVudCwgZGVsYXkpLCB0aW1lb3V0KTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFJlc3RhcnRzIHRoZSBzY2FubmVyLlxyXG4gICAqL1xyXG4gIHByaXZhdGUgcmVzdGFydCgpOiBPYnNlcnZhYmxlPFJlc3VsdEFuZEVycm9yPiB7XHJcbiAgICAvLyByZXNldFxyXG4gICAgLy8gc3RhcnRcclxuICAgIHJldHVybiB0aGlzLmNvbnRpbnVvdXNEZWNvZGVGcm9tSW5wdXRWaWRlb0RldmljZSh0aGlzLmRldmljZUlkLCB0aGlzLnZpZGVvRWxlbWVudCk7XHJcbiAgfVxyXG5cclxufVxyXG4iXX0=