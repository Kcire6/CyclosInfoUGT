import { __awaiter, __decorate, __metadata } from "tslib";
import { ChangeDetectionStrategy, Component, ElementRef, EventEmitter, Input, Output, ViewChild, } from '@angular/core';
import { ArgumentException, BarcodeFormat, DecodeHintType } from '@zxing/library';
import { BrowserMultiFormatContinuousReader } from './browser-multi-format-continuous-reader';
let ZXingScannerComponent = class ZXingScannerComponent {
    /**
     * Constructor to build the object and do some DI.
     */
    constructor() {
        /**
         * Modify delay between scans (default is 500ms)
         */
        this.timeBetweenScans = 500;
        /**
         * How the preview element shoud be fit inside the :host container.
         */
        this.previewFitMode = 'cover';
        // instance based emitters
        this.autostarted = new EventEmitter();
        this.autostarting = new EventEmitter();
        this.torchCompatible = new EventEmitter();
        this.scanSuccess = new EventEmitter();
        this.scanFailure = new EventEmitter();
        this.scanError = new EventEmitter();
        this.scanComplete = new EventEmitter();
        this.camerasFound = new EventEmitter();
        this.camerasNotFound = new EventEmitter();
        this.permissionResponse = new EventEmitter(true);
        this.hasDevices = new EventEmitter();
        this.deviceChange = new EventEmitter();
        this._device = null;
        this._enabled = true;
        this._hints = new Map();
        this.autofocusEnabled = true;
        this.autostart = true;
        this.formats = [BarcodeFormat.QR_CODE];
        // computed data
        this.hasNavigator = typeof navigator !== 'undefined';
        this.isMediaDevicesSupported = this.hasNavigator && !!navigator.mediaDevices;
    }
    /**
     * Exposes the current code reader, so the user can use it's APIs.
     */
    get codeReader() {
        return this._codeReader;
    }
    /**
     * User device input
     */
    set device(device) {
        if (!device && device !== null) {
            throw new ArgumentException('The `device` must be a valid MediaDeviceInfo or null.');
        }
        if (this.isCurrentDevice(device)) {
            console.warn('Setting the same device is not allowed.');
            return;
        }
        if (this.isAutostarting) {
            // do not allow setting devices during auto-start, since it will set one and emit it.
            console.warn('Avoid setting a device during auto-start.');
            return;
        }
        if (!this.hasPermission) {
            console.warn('Permissions not set yet, waiting for them to be set to apply device change.');
            // this.permissionResponse
            //   .pipe(
            //     take(1),
            //     tap(() => console.log(`Permissions set, applying device change${device ? ` (${device.deviceId})` : ''}.`))
            //   )
            //   .subscribe(() => this.device = device);
            // return;
        }
        // in order to change the device the codeReader gotta be reseted
        this._reset();
        this._device = device;
        // if enabled, starts scanning
        if (this._enabled && device !== null) {
            this.scanFromDevice(device.deviceId);
        }
    }
    /**
     * User device acessor.
     */
    get device() {
        return this._device;
    }
    /**
     * Returns all the registered formats.
     */
    get formats() {
        return this.hints.get(DecodeHintType.POSSIBLE_FORMATS);
    }
    /**
     * Registers formats the scanner should support.
     *
     * @param input BarcodeFormat or case-insensitive string array.
     */
    set formats(input) {
        if (typeof input === 'string') {
            throw new Error('Invalid formats, make sure the [formats] input is a binding.');
        }
        // formats may be set from html template as BarcodeFormat or string array
        const formats = input.map(f => this.getBarcodeFormatOrFail(f));
        const hints = this.hints;
        // updates the hints
        hints.set(DecodeHintType.POSSIBLE_FORMATS, formats);
        this.hints = hints;
    }
    /**
     * Returns all the registered hints.
     */
    get hints() {
        return this._hints;
    }
    /**
     * Does what it takes to set the hints.
     */
    set hints(hints) {
        this._hints = hints;
        // @note avoid restarting the code reader when possible
        // new instance with new hints.
        this.restart();
    }
    /**
     *
     */
    set isAutostarting(state) {
        this._isAutostarting = state;
        this.autostarting.next(state);
    }
    /**
     *
     */
    get isAutostarting() {
        return this._isAutostarting;
    }
    /**
     * Can turn on/off the device flashlight.
     */
    set torch(on) {
        this.getCodeReader().setTorch(on);
    }
    /**
     * Starts and Stops the scanning.
     */
    set enable(enabled) {
        this._enabled = Boolean(enabled);
        if (!this._enabled) {
            this.reset();
        }
        else if (this.device) {
            this.scanFromDevice(this.device.deviceId);
        }
    }
    /**
     * Tells if the scanner is enabled or not.
     */
    get enabled() {
        return this._enabled;
    }
    /**
     * If is `tryHarder` enabled.
     */
    get tryHarder() {
        return this.hints.get(DecodeHintType.TRY_HARDER);
    }
    /**
     * Enable/disable tryHarder hint.
     */
    set tryHarder(enable) {
        const hints = this.hints;
        if (enable) {
            hints.set(DecodeHintType.TRY_HARDER, true);
        }
        else {
            hints.delete(DecodeHintType.TRY_HARDER);
        }
        this.hints = hints;
    }
    /**
     * Gets and registers all cammeras.
     */
    askForPermission() {
        return __awaiter(this, void 0, void 0, function* () {
            if (!this.hasNavigator) {
                console.error('@zxing/ngx-scanner', 'Can\'t ask permission, navigator is not present.');
                this.setPermission(null);
                return this.hasPermission;
            }
            if (!this.isMediaDevicesSupported) {
                console.error('@zxing/ngx-scanner', 'Can\'t get user media, this is not supported.');
                this.setPermission(null);
                return this.hasPermission;
            }
            let stream;
            let permission;
            try {
                // Will try to ask for permission
                stream = yield this.getAnyVideoDevice();
                permission = !!stream;
            }
            catch (err) {
                return this.handlePermissionException(err);
            }
            finally {
                this.terminateStream(stream);
            }
            this.setPermission(permission);
            // Returns the permission
            return permission;
        });
    }
    /**
     *
     */
    getAnyVideoDevice() {
        return navigator.mediaDevices.getUserMedia({ video: true });
    }
    /**
     * Terminates a stream and it's tracks.
     */
    terminateStream(stream) {
        if (stream) {
            stream.getTracks().forEach(t => t.stop());
        }
        stream = undefined;
    }
    /**
     * Initializes the component without starting the scanner.
     */
    initAutostartOff() {
        // do not ask for permission when autostart is off
        this.isAutostarting = null;
        // just update devices information
        this.updateVideoInputDevices();
    }
    /**
     * Initializes the component and starts the scanner.
     * Permissions are asked to accomplish that.
     */
    initAutostartOn() {
        return __awaiter(this, void 0, void 0, function* () {
            this.isAutostarting = true;
            let hasPermission;
            try {
                // Asks for permission before enumerating devices so it can get all the device's info
                hasPermission = yield this.askForPermission();
            }
            catch (e) {
                console.error('Exception occurred while asking for permission:', e);
                return;
            }
            // from this point, things gonna need permissions
            if (hasPermission) {
                const devices = yield this.updateVideoInputDevices();
                this.autostartScanner([...devices]);
            }
        });
    }
    /**
     * Checks if the given device is the current defined one.
     */
    isCurrentDevice(device) {
        return this.device && device && device.deviceId === this.device.deviceId;
    }
    /**
     * Executed after the view initialization.
     */
    ngAfterViewInit() {
        // makes torch availability information available to user
        this.getCodeReader().isTorchAvailable.subscribe(x => this.torchCompatible.emit(x));
        if (!this.autostart) {
            console.warn('New feature \'autostart\' disabled, be careful. Permissions and devices recovery has to be run manually.');
            // does the necessary configuration without autostarting
            this.initAutostartOff();
            return;
        }
        // configurates the component and starts the scanner
        this.initAutostartOn();
    }
    /**
     * Executes some actions before destroy the component.
     */
    ngOnDestroy() {
        this.reset();
    }
    /**
     * Stops old `codeReader` and starts scanning in a new one.
     */
    restart() {
        const prevDevice = this._reset();
        if (!prevDevice) {
            return;
        }
        // @note apenas necessario por enquanto causa da Torch
        this._codeReader = undefined;
        this.device = prevDevice;
    }
    /**
     * Discovers and updates known video input devices.
     */
    updateVideoInputDevices() {
        return __awaiter(this, void 0, void 0, function* () {
            // permissions aren't needed to get devices, but to access them and their info
            const devices = (yield this.getCodeReader().listVideoInputDevices()) || [];
            const hasDevices = devices && devices.length > 0;
            // stores discovered devices and updates information
            this.hasDevices.next(hasDevices);
            this.camerasFound.next([...devices]);
            if (!hasDevices) {
                this.camerasNotFound.next();
            }
            return devices;
        });
    }
    /**
     * Starts the scanner with the back camera otherwise take the last
     * available device.
     */
    autostartScanner(devices) {
        const matcher = ({ label }) => /back|trás|rear|traseira|environment|ambiente/gi.test(label);
        // select the rear camera by default, otherwise take the last camera.
        const device = devices.find(matcher) || devices.pop();
        if (!device) {
            throw new Error('Impossible to autostart, no input devices available.');
        }
        this.device = device;
        // @note when listening to this change, callback code will sometimes run before the previous line.
        this.deviceChange.emit(device);
        this.isAutostarting = false;
        this.autostarted.next();
    }
    /**
     * Dispatches the scan success event.
     *
     * @param result the scan result.
     */
    dispatchScanSuccess(result) {
        this.scanSuccess.next(result.getText());
    }
    /**
     * Dispatches the scan failure event.
     */
    dispatchScanFailure(reason) {
        this.scanFailure.next(reason);
    }
    /**
     * Dispatches the scan error event.
     *
     * @param error the error thing.
     */
    dispatchScanError(error) {
        this.scanError.next(error);
    }
    /**
     * Dispatches the scan event.
     *
     * @param result the scan result.
     */
    dispatchScanComplete(result) {
        this.scanComplete.next(result);
    }
    /**
     * Returns the filtered permission.
     */
    handlePermissionException(err) {
        // failed to grant permission to video input
        console.error('@zxing/ngx-scanner', 'Error when asking for permission.', err);
        let permission;
        switch (err.name) {
            // usually caused by not secure origins
            case 'NotSupportedError':
                console.warn('@zxing/ngx-scanner', err.message);
                // could not claim
                permission = null;
                // can't check devices
                this.hasDevices.next(null);
                break;
            // user denied permission
            case 'NotAllowedError':
                console.warn('@zxing/ngx-scanner', err.message);
                // claimed and denied permission
                permission = false;
                // this means that input devices exists
                this.hasDevices.next(true);
                break;
            // the device has no attached input devices
            case 'NotFoundError':
                console.warn('@zxing/ngx-scanner', err.message);
                // no permissions claimed
                permission = null;
                // because there was no devices
                this.hasDevices.next(false);
                // tells the listener about the error
                this.camerasNotFound.next(err);
                break;
            case 'NotReadableError':
                console.warn('@zxing/ngx-scanner', 'Couldn\'t read the device(s)\'s stream, it\'s probably in use by another app.');
                // no permissions claimed
                permission = null;
                // there are devices, which I couldn't use
                this.hasDevices.next(false);
                // tells the listener about the error
                this.camerasNotFound.next(err);
                break;
            default:
                console.warn('@zxing/ngx-scanner', 'I was not able to define if I have permissions for camera or not.', err);
                // unknown
                permission = null;
                // this.hasDevices.next(undefined;
                break;
        }
        this.setPermission(permission);
        // tells the listener about the error
        this.permissionResponse.error(err);
        return permission;
    }
    /**
     * Returns a valid BarcodeFormat or fails.
     */
    getBarcodeFormatOrFail(format) {
        return typeof format === 'string'
            ? BarcodeFormat[format.trim().toUpperCase()]
            : format;
    }
    /**
     * Retorna um code reader, cria um se nenhume existe.
     */
    getCodeReader() {
        if (!this._codeReader) {
            this._codeReader = new BrowserMultiFormatContinuousReader(this.hints, this.timeBetweenScans);
        }
        return this._codeReader;
    }
    /**
     * Starts the continuous scanning for the given device.
     *
     * @param deviceId The deviceId from the device.
     */
    scanFromDevice(deviceId) {
        const videoElement = this.previewElemRef.nativeElement;
        const codeReader = this.getCodeReader();
        const decodingStream = codeReader.continuousDecodeFromInputVideoDevice(deviceId, videoElement);
        if (!decodingStream) {
            throw new Error('Undefined decoding stream, aborting.');
        }
        const next = (x) => this._onDecodeResult(x.result, x.error);
        const error = (err) => this._onDecodeError(err);
        const complete = () => { this.reset(); console.log('completed'); };
        decodingStream.subscribe(next, error, complete);
    }
    /**
     * Handles decode errors.
     */
    _onDecodeError(err) {
        this.dispatchScanError(err);
        this.reset();
    }
    /**
     * Handles decode results.
     */
    _onDecodeResult(result, error) {
        if (result) {
            this.dispatchScanSuccess(result);
        }
        else {
            this.dispatchScanFailure(error);
        }
        this.dispatchScanComplete(result);
    }
    /**
     * Stops the code reader and returns the previous selected device.
     */
    _reset() {
        if (!this._codeReader) {
            return;
        }
        const device = this.device;
        // do not set this.device inside this method, it would create a recursive loop
        this._device = null;
        this._codeReader.reset();
        return device;
    }
    /**
     * Resets the scanner and emits device change.
     */
    reset() {
        this._reset();
        this.deviceChange.emit(null);
    }
    /**
     * Sets the permission value and emmits the event.
     */
    setPermission(hasPermission) {
        this.hasPermission = hasPermission;
        this.permissionResponse.next(hasPermission);
    }
};
__decorate([
    ViewChild('preview', { static: true }),
    __metadata("design:type", ElementRef)
], ZXingScannerComponent.prototype, "previewElemRef", void 0);
__decorate([
    Input(),
    __metadata("design:type", Boolean)
], ZXingScannerComponent.prototype, "autofocusEnabled", void 0);
__decorate([
    Input(),
    __metadata("design:type", Object)
], ZXingScannerComponent.prototype, "timeBetweenScans", void 0);
__decorate([
    Output(),
    __metadata("design:type", EventEmitter)
], ZXingScannerComponent.prototype, "autostarted", void 0);
__decorate([
    Output(),
    __metadata("design:type", EventEmitter)
], ZXingScannerComponent.prototype, "autostarting", void 0);
__decorate([
    Input(),
    __metadata("design:type", Boolean)
], ZXingScannerComponent.prototype, "autostart", void 0);
__decorate([
    Input(),
    __metadata("design:type", String)
], ZXingScannerComponent.prototype, "previewFitMode", void 0);
__decorate([
    Output(),
    __metadata("design:type", EventEmitter)
], ZXingScannerComponent.prototype, "torchCompatible", void 0);
__decorate([
    Output(),
    __metadata("design:type", EventEmitter)
], ZXingScannerComponent.prototype, "scanSuccess", void 0);
__decorate([
    Output(),
    __metadata("design:type", EventEmitter)
], ZXingScannerComponent.prototype, "scanFailure", void 0);
__decorate([
    Output(),
    __metadata("design:type", EventEmitter)
], ZXingScannerComponent.prototype, "scanError", void 0);
__decorate([
    Output(),
    __metadata("design:type", EventEmitter)
], ZXingScannerComponent.prototype, "scanComplete", void 0);
__decorate([
    Output(),
    __metadata("design:type", EventEmitter)
], ZXingScannerComponent.prototype, "camerasFound", void 0);
__decorate([
    Output(),
    __metadata("design:type", EventEmitter)
], ZXingScannerComponent.prototype, "camerasNotFound", void 0);
__decorate([
    Output(),
    __metadata("design:type", EventEmitter)
], ZXingScannerComponent.prototype, "permissionResponse", void 0);
__decorate([
    Output(),
    __metadata("design:type", EventEmitter)
], ZXingScannerComponent.prototype, "hasDevices", void 0);
__decorate([
    Input(),
    __metadata("design:type", MediaDeviceInfo),
    __metadata("design:paramtypes", [MediaDeviceInfo])
], ZXingScannerComponent.prototype, "device", null);
__decorate([
    Output(),
    __metadata("design:type", EventEmitter)
], ZXingScannerComponent.prototype, "deviceChange", void 0);
__decorate([
    Input(),
    __metadata("design:type", Array),
    __metadata("design:paramtypes", [Array])
], ZXingScannerComponent.prototype, "formats", null);
__decorate([
    Input(),
    __metadata("design:type", Boolean),
    __metadata("design:paramtypes", [Boolean])
], ZXingScannerComponent.prototype, "torch", null);
__decorate([
    Input(),
    __metadata("design:type", Boolean),
    __metadata("design:paramtypes", [Boolean])
], ZXingScannerComponent.prototype, "enable", null);
__decorate([
    Input(),
    __metadata("design:type", Boolean),
    __metadata("design:paramtypes", [Boolean])
], ZXingScannerComponent.prototype, "tryHarder", null);
ZXingScannerComponent = __decorate([
    Component({
        selector: 'zxing-scanner',
        template: "<video #preview [style.object-fit]=\"previewFitMode\">\r\n  <p>\r\n    Your browser does not support this feature, please try to upgrade it.\r\n  </p>\r\n  <p>\r\n    Seu navegador n\u00E3o suporta este recurso, por favor tente atualiz\u00E1-lo.\r\n  </p>\r\n</video>\r\n",
        changeDetection: ChangeDetectionStrategy.OnPush,
        styles: [":host{display:block}video{width:100%;height:auto;-o-object-fit:contain;object-fit:contain}"]
    }),
    __metadata("design:paramtypes", [])
], ZXingScannerComponent);
export { ZXingScannerComponent };
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoienhpbmctc2Nhbm5lci5jb21wb25lbnQuanMiLCJzb3VyY2VSb290Ijoibmc6Ly9Aenhpbmcvbmd4LXNjYW5uZXIvIiwic291cmNlcyI6WyJsaWIvenhpbmctc2Nhbm5lci5jb21wb25lbnQudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IjtBQUFBLE9BQU8sRUFFTCx1QkFBdUIsRUFDdkIsU0FBUyxFQUNULFVBQVUsRUFDVixZQUFZLEVBQ1osS0FBSyxFQUVMLE1BQU0sRUFDTixTQUFTLEdBQ1YsTUFBTSxlQUFlLENBQUM7QUFFdkIsT0FBTyxFQUNMLGlCQUFpQixFQUNqQixhQUFhLEVBQ2IsY0FBYyxFQUdmLE1BQU0sZ0JBQWdCLENBQUM7QUFFeEIsT0FBTyxFQUFFLGtDQUFrQyxFQUFFLE1BQU0sMENBQTBDLENBQUM7QUFTOUYsSUFBYSxxQkFBcUIsR0FBbEMsTUFBYSxxQkFBcUI7SUFnVWhDOztPQUVHO0lBQ0g7UUE3UUE7O1dBRUc7UUFFSCxxQkFBZ0IsR0FBRyxHQUFHLENBQUM7UUFvQnZCOztXQUVHO1FBRUgsbUJBQWMsR0FBeUQsT0FBTyxDQUFDO1FBa1A3RSwwQkFBMEI7UUFDMUIsSUFBSSxDQUFDLFdBQVcsR0FBRyxJQUFJLFlBQVksRUFBRSxDQUFDO1FBQ3RDLElBQUksQ0FBQyxZQUFZLEdBQUcsSUFBSSxZQUFZLEVBQUUsQ0FBQztRQUN2QyxJQUFJLENBQUMsZUFBZSxHQUFHLElBQUksWUFBWSxFQUFFLENBQUM7UUFDMUMsSUFBSSxDQUFDLFdBQVcsR0FBRyxJQUFJLFlBQVksRUFBRSxDQUFDO1FBQ3RDLElBQUksQ0FBQyxXQUFXLEdBQUcsSUFBSSxZQUFZLEVBQUUsQ0FBQztRQUN0QyxJQUFJLENBQUMsU0FBUyxHQUFHLElBQUksWUFBWSxFQUFFLENBQUM7UUFDcEMsSUFBSSxDQUFDLFlBQVksR0FBRyxJQUFJLFlBQVksRUFBRSxDQUFDO1FBQ3ZDLElBQUksQ0FBQyxZQUFZLEdBQUcsSUFBSSxZQUFZLEVBQUUsQ0FBQztRQUN2QyxJQUFJLENB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R1A7QUFNRDtJQURDLEtBQUssRUFBRTs7O21EQVVQO0FBb0JEO0lBREMsS0FBSyxFQUFFOzs7c0RBWVA7QUE5VFUscUJBQXFCO0lBTmpDLFNBQVMsQ0FBQztRQUNULFFBQVEsRUFBRSxlQUFlO1FBQ3pCLDJSQUE2QztRQUU3QyxlQUFlLEVBQUUsdUJBQXVCLENBQUMsTUFBTTs7S0FDaEQsQ0FBQzs7R0FDVyxxQkFBcUIsQ0FtdUJqQztTQW51QlkscUJBQXFCIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHtcclxuICBBZnRlclZpZXdJbml0LFxyXG4gIENoYW5nZURldGVjdGlvblN0cmF0ZWd5LFxyXG4gIENvbXBvbmVudCxcclxuICBFbGVtZW50UmVmLFxyXG4gIEV2ZW50RW1pdHRlcixcclxuICBJbnB1dCxcclxuICBPbkRlc3Ryb3ksXHJcbiAgT3V0cHV0LFxyXG4gIFZpZXdDaGlsZCxcclxufSBmcm9tICdAYW5ndWxhci9jb3JlJztcclxuXHJcbmltcG9ydCB7XHJcbiAgQXJndW1lbnRFeGNlcHRpb24sXHJcbiAgQmFyY29kZUZvcm1hdCxcclxuICBEZWNvZGVIaW50VHlwZSxcclxuICBFeGNlcHRpb24sXHJcbiAgUmVzdWx0XHJcbn0gZnJvbSAnQHp4aW5nL2xpYnJhcnknO1xyXG5cclxuaW1wb3J0IHsgQnJvd3Nlck11bHRpRm9ybWF0Q29udGludW91c1JlYWRlciB9IGZyb20gJy4vYnJvd3Nlci1tdWx0aS1mb3JtYXQtY29udGludW91cy1yZWFkZXInO1xyXG5pbXBvcnQgeyBSZXN1bHRBbmRFcnJvciB9IGZyb20gJy4vUmVzdWx0QW5kRXJyb3InO1xyXG5cclxuQENvbXBvbmVudCh7XHJcbiAgc2VsZWN0b3I6ICd6eGluZy1zY2FubmVyJyxcclxuICB0ZW1wbGF0ZVVybDogJy4venhpbmctc2Nhbm5lci5jb21wb25lbnQuaHRtbCcsXHJcbiAgc3R5bGVVcmxzOiBbJy4venhpbmctc2Nhbm5lci5jb21wb25lbnQuc2NzcyddLFxyXG4gIGNoYW5nZURldGVjdGlvbjogQ2hhbmdlRGV0ZWN0aW9uU3RyYXRlZ3kuT25QdXNoXHJcbn0pXHJcbmV4cG9ydCBjbGFzcyBaWGluZ1NjYW5uZXJDb21wb25lbnQgaW1wbGVtZW50cyBBZnRlclZpZXdJbml0LCBPbkRlc3Ryb3kge1xyXG5cclxuICAvKipcclxuICAgKiBTdXBwb3J0ZWQgSGludHMgbWFwLlxyXG4gICAqL1xyXG4gIHByaXZhdGUgX2hpbnRzOiBNYXA8RGVjb2RlSGludFR5cGUsIGFueT4gfCBudWxsO1xyXG5cclxuICAvKipcclxuICAgKiBUaGUgWlhpbmcgY29kZSByZWFkZXIuXHJcbiAgICovXHJcbiAgcHJpdmF0ZSBfY29kZVJlYWRlcjogQnJvd3Nlck11bHRpRm9ybWF0Q29udGludW91c1JlYWRlcjtcclxuXHJcbiAgLyoqXHJcbiAgICogVGhlIGRldmljZSB0aGF0IHNob3VsZCBiZSB1c2VkIHRvIHNjYW4gdGhpbmdzLlxyXG4gICAqL1xyXG4gIHByaXZhdGUgX2RldmljZTogTWVkaWFEZXZpY2VJbmZvO1xyXG5cclxuICAvKipcclxuICAgKiBUaGUgZGV2aWNlIHRoYXQgc2hvdWxkIGJlIHVzZWQgdG8gc2NhbiB0aGluZ3MuXHJcbiAgICovXHJcbiAgcHJpdmF0ZSBfZW5hYmxlZDogYm9vbGVhbjtcclxuXHJcbiAgLyoqXHJcbiAgICpcclxuICAgKi9cclxuICBwcml2YXRlIF9pc0F1dG9zdGFydGluZzogYm9vbGVhbjtcclxuXHJcbiAgLyoqXHJcbiAgICogSGFzIGBuYXZpZ2F0b3JgIGFjY2Vzcy5cclxuICAgKi9cclxuICBwcml2YXRlIGhhc05hdmlnYXRvcjogYm9vbGVhbjtcclxuXHJcbiAgLyoqXHJcbiAgICogU2F5cyBpZiBzb21lIG5hdGl2ZSBBUEkgaXMgc3VwcG9ydGVkLlxyXG4gICAqL1xyXG4gIHByaXZhdGUgaXNNZWRpYURldmljZXNTdXBwb3J0ZWQ6IGJvb2xlYW47XHJcblxyXG4gIC8qKlxyXG4gICAqIElmIHRoZSB1c2VyLWFnZW50IGFsbG93ZWQgdGhlIHVzZSBvZiB0aGUgY2FtZXJhIG9yIG5vdC5cclxuICAgKi9cclxuICBwcml2YXRlIGhhc1Blcm1pc3Npb246IGJvb2xlYW4gfCBudWxsO1xyXG5cclxuICAvKipcclxuICAgKiBSZWZlcmVuY2UgdG8gdGhlIHByZXZpZXcgZWxlbWVudCwgc2hvdWxkIGJlIHRoZSBgdmlkZW9gIHRhZy5cclxuICAgKi9cclxuICBAVmlld0NoaWxkKCdwcmV2aWV3JywgeyBzdGF0aWM6IHRydWUgfSlcclxuICBwcmV2aWV3RWxlbVJlZjogRWxlbWVudFJlZjxIVE1MVmlkZW9FbGVtZW50PjtcclxuXHJcbiAgLyoqXHJcbiAgICogRW5hYmxlIG9yIGRpc2FibGUgYXV0b2ZvY3VzIG9mIHRoZSBjYW1lcmEgKG1pZ2h0IGhhdmUgYW4gaW1wYWN0IG9uIHBlcmZvcm1hbmNlKVxyXG4gICAqL1xyXG4gIEBJbnB1dCgpXHJcbiAgYXV0b2ZvY3VzRW5hYmxlZDogYm9vbGVhbjtcclxuXHJcbiAgLyoqXHJcbiAgICogTW9kaWZ5IGRlbGF5IGJldHdlZW4gc2NhbnMgKGRlZmF1bHQgaXMgNTAwbXMpXHJcbiAgICovXHJcbiAgQElucHV0KClcclxuICB0aW1lQmV0d2VlblNjYW5zID0gNTAwO1xyXG5cclxuICAvKipcclxuICAgKiBFbWl0cyB3aGVuIGFuZCBpZiB0aGUgc2Nhbm5lciBpcyBhdXRvc3RhcnRlZC5cclxuICAgKi9cclxuICBAT3V0cHV0KClcclxuICBhdXRvc3RhcnRlZDogRXZlbnRFbWl0dGVyPHZvaWQ+O1xyXG5cclxuICAvKipcclxuICAgKiBUcnVlIGR1cmluZyBhdXRvc3RhcnQgYW5kIGZhbHNlIGFmdGVyLiBJdCB3aWxsIGJlIG51bGwgaWYgd29uJ3QgYXV0b3N0YXJ0IGF0IGFsbC5cclxuICAgKi9cclxuICBAT3V0cHV0KClcclxuICBhdXRvc3RhcnRpbmc6IEV2ZW50RW1pdHRlcjxib29sZWFuIHwgbnVsbD47XHJcblxyXG4gIC8qKlxyXG4gICAqIElmIHRoZSBzY2FubmVyIHNob3VsZCBhdXRvc3RhcnQgd2l0aCB0aGUgZmlyc3QgYXZhaWxhYmxlIGRldmljZS5cclxuICAgKi9cclxuICBASW5wdXQoKVxyXG4gIGF1dG9zdGFydDogYm9vbGVhbjtcclxuXHJcbiAgLyoqXHJcbiAgICogSG93IHRoZSBwcmV2aWV3IGVsZW1lbnQgc2hvdWQgYmUgZml0IGluc2lkZSB0aGUgOmhvc3QgY29udGFpbmVyLlxyXG4gICAqL1xyXG4gIEBJbnB1dCgpXHJcbiAgcHJldmlld0ZpdE1vZGU6ICdmaWxsJyB8ICdjb250YWluJyB8ICdjb3ZlcicgfCAnc2NhbGUtZG93bicgfCAnbm9uZScgPSAnY292ZXInO1xyXG5cclxuICAvKipcclxuICAgKiBFbWl0dHMgZXZlbnRzIHdoZW4gdGhlIHRvcmNoIGNvbXBhdGliaWxpdHkgaXMgY2hhbmdlZC5cclxuICAgKi9cclxuICBAT3V0cHV0KClcclxuICB0b3JjaENvbXBhdGlibGU6IEV2ZW50RW1pdHRlcjxib29sZWFuPjtcclxuXHJcbiAgLyoqXHJcbiAgICogRW1pdHRzIGV2ZW50cyB3aGVuIGEgc2NhbiBpcyBzdWNjZXNzZnVsIHBlcmZvcm1lZCwgd2lsbCBpbmplY3QgdGhlIHN0cmluZyB2YWx1ZSBvZiB0aGUgUVItY29kZSB0byB0aGUgY2FsbGJhY2suXHJcbiAgICovXHJcbiAgQE91dHB1dCgpXHJcbiAgc2NhblN1Y2Nlc3M6IEV2ZW50RW1pdHRlcjxzdHJpbmc+O1xyXG5cclxuICAvKipcclxuICAgKiBFbWl0dHMgZXZlbnRzIHdoZW4gYSBzY2FuIGZhaWxzIHdpdGhvdXQgZXJyb3JzLCB1c2VmdWxsIHRvIGtub3cgaG93IG11Y2ggc2NhbiB0cmllcyB3aGVyZSBtYWRlLlxyXG4gICAqL1xyXG4gIEBPdXRwdXQoKVxyXG4gIHNjYW5GYWlsdXJlOiBFdmVudEVtaXR0ZXI8RXhjZXB0aW9uIHwgdW5kZWZpbmVkPjtcclxuXHJcbiAgLyoqXHJcbiAgICogRW1pdHRzIGV2ZW50cyB3aGVuIGEgc2NhbiB0aHJvd3Mgc29tZSBlcnJvciwgd2lsbCBpbmplY3QgdGhlIGVycm9yIHRvIHRoZSBjYWxsYmFjay5cclxuICAgKi9cclxuICBAT3V0cHV0KClcclxuICBzY2FuRXJyb3I6IEV2ZW50RW1pdHRlcjxFcnJvcj47XHJcblxyXG4gIC8qKlxyXG4gICAqIEVtaXR0cyBldmVudHMgd2hlbiBhIHNjYW4gaXMgcGVyZm9ybWVkLCB3aWxsIGluamVjdCB0aGUgUmVzdWx0IHZhbHVlIG9mIHRoZSBRUi1jb2RlIHNjYW4gKGlmIGF2YWlsYWJsZSkgdG8gdGhlIGNhbGxiYWNrLlxyXG4gICAqL1xyXG4gIEBPdXRwdXQoKVxyXG4gIHNjYW5Db21wbGV0ZTogRXZlbnRFbWl0dGVyPFJlc3VsdD47XHJcblxyXG4gIC8qKlxyXG4gICAqIEVtaXR0cyBldmVudHMgd2hlbiBubyBjYW1lcmFzIGFyZSBmb3VuZCwgd2lsbCBpbmplY3QgYW4gZXhjZXB0aW9uIChpZiBhdmFpbGFibGUpIHRvIHRoZSBjYWxsYmFjay5cclxuICAgKi9cclxuICBAT3V0cHV0KClcclxuICBjYW1lcmFzRm91bmQ6IEV2ZW50RW1pdHRlcjxNZWRpYURldmljZUluZm9bXT47XHJcblxyXG4gIC8qKlxyXG4gICAqIEVtaXR0cyBldmVudHMgd2hlbiBubyBjYW1lcmFzIGFyZSBmb3VuZCwgd2lsbCBpbmplY3QgYW4gZXhjZXB0aW9uIChpZiBhdmFpbGFibGUpIHRvIHRoZSBjYWxsYmFjay5cclxuICAgKi9cclxuICBAT3V0cHV0KClcclxuICBjYW1lcmFzTm90Rm91bmQ6IEV2ZW50RW1pdHRlcjxhbnk+O1xyXG5cclxuICAvKipcclxuICAgKiBFbWl0dHMgZXZlbnRzIHdoZW4gdGhlIHVzZXJzIGFuc3dlcnMgZm9yIHBlcm1pc3Npb24uXHJcbiAgICovXHJcbiAgQE91dHB1dCgpXHJcbiAgcGVybWlzc2lvblJlc3BvbnNlOiBFdmVudEVtaXR0ZXI8Ym9vbGVhbj47XHJcblxyXG4gIC8qKlxyXG4gICAqIEVtaXR0cyBldmVudHMgd2hlbiBoYXMgZGV2aWNlcyBzdGF0dXMgaXMgdXBkYXRlLlxyXG4gICAqL1xyXG4gIEBPdXRwdXQoKVxyXG4gIGhhc0RldmljZXM6IEV2ZW50RW1pdHRlcjxib29sZWFuPjtcclxuXHJcbiAgLyoqXHJcbiAgICogRXhwb3NlcyB0aGUgY3VycmVudCBjb2RlIHJlYWRlciwgc28gdGhlIHVzZXIgY2FuIHVzZSBpdCdzIEFQSXMuXHJcbiAgICovXHJcbiAgZ2V0IGNvZGVSZWFkZXIoKTogQnJvd3Nlck11bHRpRm9ybWF0Q29udGludW91c1JlYWRlciB7XHJcbiAgICByZXR1cm4gdGhpcy5fY29kZVJlYWRlcjtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFVzZXIgZGV2aWNlIGlucHV0XHJcbiAgICovXHJcbiAgQElucHV0KClcclxuICBzZXQgZGV2aWNlKGRldmljZTogTWVkaWFEZXZpY2VJbmZvIHwgbnVsbCkge1xyXG5cclxuICAgIGlmICghZGV2aWNlICYmIGRldmljZSAhPT0gbnVsbCkge1xyXG4gICAgICB0aHJvdyBuZXcgQXJndW1lbnRFeGNlcHRpb24oJ1RoZSBgZGV2aWNlYCBtdXN0IGJlIGEgdmFsaWQgTWVkaWFEZXZpY2VJbmZvIG9yIG51bGwuJyk7XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKHRoaXMuaXNDdXJyZW50RGV2aWNlKGRldmljZSkpIHtcclxuICAgICAgY29uc29sZS53YXJuKCdTZXR0aW5nIHRoZSBzYW1lIGRldmljZSBpcyBub3QgYWxsb3dlZC4nKTtcclxuICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG5cclxuICAgIGlmICh0aGlzLmlzQXV0b3N0YXJ0aW5nKSB7XHJcbiAgICAgIC8vIGRvIG5vdCBhbGxvdyBzZXR0aW5nIGRldmljZXMgZHVyaW5nIGF1dG8tc3RhcnQsIHNpbmNlIGl0IHdpbGwgc2V0IG9uZSBhbmQgZW1pdCBpdC5cclxuICAgICAgY29uc29sZS53YXJuKCdBdm9pZCBzZXR0aW5nIGEgZGV2aWNlIGR1cmluZyBhdXRvLXN0YXJ0LicpO1xyXG4gICAgICByZXR1cm47XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKCF0aGlzLmhhc1Blcm1pc3Npb24pIHtcclxuICAgICAgY29uc29sZS53YXJuKCdQZXJtaXNzaW9ucyBub3Qgc2V0IHlldCwgd2FpdGluZyBmb3IgdGhlbSB0byBiZSBzZXQgdG8gYXBwbHkgZGV2aWNlIGNoYW5nZS4nKTtcclxuICAgICAgLy8gdGhpcy5wZXJtaXNzaW9uUmVzcG9uc2VcclxuICAgICAgLy8gICAucGlwZShcclxuICAgICAgLy8gICAgIHRha2UoMSksXHJcbiAgICAgIC8vICAgICB0YXAoKCkgPT4gY29uc29sZS5sb2coYFBlcm1pc3Npb25zIHNldCwgYXBwbHlpbmcgZGV2aWNlIGNoYW5nZSR7ZGV2aWNlID8gYCAoJHtkZXZpY2UuZGV2aWNlSWR9KWAgOiAnJ30uYCkpXHJcbiAgICAgIC8vICAgKVxyXG4gICAgICAvLyAgIC5zdWJzY3JpYmUoKCkgPT4gdGhpcy5kZXZpY2UgPSBkZXZpY2UpO1xyXG4gICAgICAvLyByZXR1cm47XHJcbiAgICB9XHJcblxyXG4gICAgLy8gaW4gb3JkZXIgdG8gY2hhbmdlIHRoZSBkZXZpY2UgdGhlIGNvZGVSZWFkZXIgZ290dGEgYmUgcmVzZXRlZFxyXG4gICAgdGhpcy5fcmVzZXQoKTtcclxuXHJcbiAgICB0aGlzLl9kZXZpY2UgPSBkZXZpY2U7XHJcblxyXG4gICAgLy8gaWYgZW5hYmxlZCwgc3RhcnRzIHNjYW5uaW5nXHJcbiAgICBpZiAodGhpcy5fZW5hYmxlZCAmJiBkZXZpY2UgIT09IG51bGwpIHtcclxuICAgICAgdGhpcy5zY2FuRnJvbURldmljZShkZXZpY2UuZGV2aWNlSWQpO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogRW1pdHMgd2hlbiB0aGUgY3VycmVudCBkZXZpY2UgaXMgY2hhbmdlZC5cclxuICAgKi9cclxuICBAT3V0cHV0KClcclxuICBkZXZpY2VDaGFuZ2U6IEV2ZW50RW1pdHRlcjxNZWRpYURldmljZUluZm8+O1xyXG5cclxuICAvKipcclxuICAgKiBVc2VyIGRldmljZSBhY2Vzc29yLlxyXG4gICAqL1xyXG4gIGdldCBkZXZpY2UoKSB7XHJcbiAgICByZXR1cm4gdGhpcy5fZGV2aWNlO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogUmV0dXJucyBhbGwgdGhlIHJlZ2lzdGVyZWQgZm9ybWF0cy5cclxuICAgKi9cclxuICBnZXQgZm9ybWF0cygpOiBCYXJjb2RlRm9ybWF0W10ge1xyXG4gICAgcmV0dXJuIHRoaXMuaGludHMuZ2V0KERlY29kZUhpbnRUeXBlLlBPU1NJQkxFX0ZPUk1BVFMpO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogUmVnaXN0ZXJzIGZvcm1hdHMgdGhlIHNjYW5uZXIgc2hvdWxkIHN1cHBvcnQuXHJcbiAgICpcclxuICAgKiBAcGFyYW0gaW5wdXQgQmFyY29kZUZvcm1hdCBvciBjYXNlLWluc2Vuc2l0aXZlIHN0cmluZyBhcnJheS5cclxuICAgKi9cclxuICBASW5wdXQoKVxyXG4gIHNldCBmb3JtYXRzKGlucHV0OiBCYXJjb2RlRm9ybWF0W10pIHtcclxuXHJcbiAgICBpZiAodHlwZW9mIGlucHV0ID09PSAnc3RyaW5nJykge1xyXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgZm9ybWF0cywgbWFrZSBzdXJlIHRoZSBbZm9ybWF0c10gaW5wdXQgaXMgYSBiaW5kaW5nLicpO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIGZvcm1hdHMgbWF5IGJlIHNldCBmcm9tIGh0bWwgdGVtcGxhdGUgYXMgQmFyY29kZUZvcm1hdCBvciBzdHJpbmcgYXJyYXlcclxuICAgIGNvbnN0IGZvcm1hdHMgPSBpbnB1dC5tYXAoZiA9PiB0aGlzLmdldEJhcmNvZGVGb3JtYXRPckZhaWwoZikpO1xyXG5cclxuICAgIGNvbnN0IGhpbnRzID0gdGhpcy5oaW50cztcclxuXHJcbiAgICAvLyB1cGRhdGVzIHRoZSBoaW50c1xyXG4gICAgaGludHMuc2V0KERlY29kZUhpbnRUeXBlLlBPU1NJQkxFX0ZPUk1BVFMsIGZvcm1hdHMpO1xyXG5cclxuICAgIHRoaXMuaGludHMgPSBoaW50cztcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFJldHVybnMgYWxsIHRoZSByZWdpc3RlcmVkIGhpbnRzLlxyXG4gICAqL1xyXG4gIGdldCBoaW50cygpIHtcclxuICAgIHJldHVybiB0aGlzLl9oaW50cztcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIERvZXMgd2hhdCBpdCB0YWtlcyB0byBzZXQgdGhlIGhpbnRzLlxyXG4gICAqL1xyXG4gIHNldCBoaW50cyhoaW50czogTWFwPERlY29kZUhpbnRUeXBlLCBhbnk+KSB7XHJcblxyXG4gICAgdGhpcy5faGludHMgPSBoaW50cztcclxuXHJcbiAgICAvLyBAbm90ZSBhdm9pZCByZXN0YXJ0aW5nIHRoZSBjb2RlIHJlYWRlciB3aGVuIHBvc3NpYmxlXHJcblxyXG4gICAgLy8gbmV3IGluc3RhbmNlIHdpdGggbmV3IGhpbnRzLlxyXG4gICAgdGhpcy5yZXN0YXJ0KCk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKlxyXG4gICAqL1xyXG4gIHNldCBpc0F1dG9zdGFydGluZyhzdGF0ZTogYm9vbGVhbiB8IG51bGwpIHtcclxuICAgIHRoaXMuX2lzQXV0b3N0YXJ0aW5nID0gc3RhdGU7XHJcbiAgICB0aGlzLmF1dG9zdGFydGluZy5uZXh0KHN0YXRlKTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqXHJcbiAgICovXHJcbiAgZ2V0IGlzQXV0b3N0YXJ0aW5nKCk6IGJvb2xlYW4gfCBudWxsIHtcclxuICAgIHJldHVybiB0aGlzLl9pc0F1dG9zdGFydGluZztcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIENhbiB0dXJuIG9uL29mZiB0aGUgZGV2aWNlIGZsYXNobGlnaHQuXHJcbiAgICovXHJcbiAgQElucHV0KClcclxuICBzZXQgdG9yY2gob246IGJvb2xlYW4pIHtcclxuICAgIHRoaXMuZ2V0Q29kZVJlYWRlcigpLnNldFRvcmNoKG9uKTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFN0YXJ0cyBhbmQgU3RvcHMgdGhlIHNjYW5uaW5nLlxyXG4gICAqL1xyXG4gIEBJbnB1dCgpXHJcbiAgc2V0IGVuYWJsZShlbmFibGVkOiBib29sZWFuKSB7XHJcblxyXG4gICAgdGhpcy5fZW5hYmxlZCA9IEJvb2xlYW4oZW5hYmxlZCk7XHJcblxyXG4gICAgaWYgKCF0aGlzLl9lbmFibGVkKSB7XHJcbiAgICAgIHRoaXMucmVzZXQoKTtcclxuICAgIH0gZWxzZSBpZiAodGhpcy5kZXZpY2UpIHtcclxuICAgICAgdGhpcy5zY2FuRnJvbURldmljZSh0aGlzLmRldmljZS5kZXZpY2VJZCk7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBUZWxscyBpZiB0aGUgc2Nhbm5lciBpcyBlbmFibGVkIG9yIG5vdC5cclxuICAgKi9cclxuICBnZXQgZW5hYmxlZCgpOiBib29sZWFuIHtcclxuICAgIHJldHVybiB0aGlzLl9lbmFibGVkO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogSWYgaXMgYHRyeUhhcmRlcmAgZW5hYmxlZC5cclxuICAgKi9cclxuICBnZXQgdHJ5SGFyZGVyKCk6IGJvb2xlYW4ge1xyXG4gICAgcmV0dXJuIHRoaXMuaGludHMuZ2V0KERlY29kZUhpbnRUeXBlLlRSWV9IQVJERVIpO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogRW5hYmxlL2Rpc2FibGUgdHJ5SGFyZGVyIGhpbnQuXHJcbiAgICovXHJcbiAgQElucHV0KClcclxuICBzZXQgdHJ5SGFyZGVyKGVuYWJsZTogYm9vbGVhbikge1xyXG5cclxuICAgIGNvbnN0IGhpbnRzID0gdGhpcy5oaW50cztcclxuXHJcbiAgICBpZiAoZW5hYmxlKSB7XHJcbiAgICAgIGhpbnRzLnNldChEZWNvZGVIaW50VHlwZS5UUllfSEFSREVSLCB0cnVlKTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIGhpbnRzLmRlbGV0ZShEZWNvZGVIaW50VHlwZS5UUllfSEFSREVSKTtcclxuICAgIH1cclxuXHJcbiAgICB0aGlzLmhpbnRzID0gaGludHM7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBDb25zdHJ1Y3RvciB0byBidWlsZCB0aGUgb2JqZWN0IGFuZCBkbyBzb21lIERJLlxyXG4gICAqL1xyXG4gIGNvbnN0cnVjdG9yKCkge1xyXG4gICAgLy8gaW5zdGFuY2UgYmFzZWQgZW1pdHRlcnNcclxuICAgIHRoaXMuYXV0b3N0YXJ0ZWQgPSBuZXcgRXZlbnRFbWl0dGVyKCk7XHJcbiAgICB0aGlzLmF1dG9zdGFydGluZyA9IG5ldyBFdmVudEVtaXR0ZXIoKTtcclxuICAgIHRoaXMudG9yY2hDb21wYXRpYmxlID0gbmV3IEV2ZW50RW1pdHRlcigpO1xyXG4gICAgdGhpcy5zY2FuU3VjY2VzcyA9IG5ldyBFdmVudEVtaXR0ZXIoKTtcclxuICAgIHRoaXMuc2NhbkZhaWx1cmUgPSBuZXcgRXZlbnRFbWl0dGVyKCk7XHJcbiAgICB0aGlzLnNjYW5FcnJvciA9IG5ldyBFdmVudEVtaXR0ZXIoKTtcclxuICAgIHRoaXMuc2NhbkNvbXBsZXRlID0gbmV3IEV2ZW50RW1pdHRlcigpO1xyXG4gICAgdGhpcy5jYW1lcmFzRm91bmQgPSBuZXcgRXZlbnRFbWl0dGVyKCk7XHJcbiAgICB0aGlzLmNhbWVyYXNOb3RGb3VuZCA9IG5ldyBFdmVudEVtaXR0ZXIoKTtcclxuICAgIHRoaXMucGVybWlzc2lvblJlc3BvbnNlID0gbmV3IEV2ZW50RW1pdHRlcih0cnVlKTtcclxuICAgIHRoaXMuaGFzRGV2aWNlcyA9IG5ldyBFdmVudEVtaXR0ZXIoKTtcclxuICAgIHRoaXMuZGV2aWNlQ2hhbmdlID0gbmV3IEV2ZW50RW1pdHRlcigpO1xyXG5cclxuICAgIHRoaXMuX2RldmljZSA9IG51bGw7XHJcbiAgICB0aGlzLl9lbmFibGVkID0gdHJ1ZTtcclxuICAgIHRoaXMuX2hpbnRzID0gbmV3IE1hcDxEZWNvZGVIaW50VHlwZSwgYW55PigpO1xyXG4gICAgdGhpcy5hdXRvZm9jdXNFbmFibGVkID0gdHJ1ZTtcclxuICAgIHRoaXMuYXV0b3N0YXJ0ID0gdHJ1ZTtcclxuICAgIHRoaXMuZm9ybWF0cyA9IFtCYXJjb2RlRm9ybWF0LlFSX0NPREVdO1xyXG5cclxuICAgIC8vIGNvbXB1dGVkIGRhdGFcclxuICAgIHRoaXMuaGFzTmF2aWdhdG9yID0gdHlwZW9mIG5hdmlnYXRvciAhPT0gJ3VuZGVmaW5lZCc7XHJcbiAgICB0aGlzLmlzTWVkaWFEZXZpY2VzU3VwcG9ydGVkID0gdGhpcy5oYXNOYXZpZ2F0b3IgJiYgISFuYXZpZ2F0b3IubWVkaWFEZXZpY2VzO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogR2V0cyBhbmQgcmVnaXN0ZXJzIGFsbCBjYW1tZXJhcy5cclxuICAgKi9cclxuICBhc3luYyBhc2tGb3JQZXJtaXNzaW9uKCk6IFByb21pc2U8Ym9vbGVhbj4ge1xyXG5cclxuICAgIGlmICghdGhpcy5oYXNOYXZpZ2F0b3IpIHtcclxuICAgICAgY29uc29sZS5lcnJvcignQHp4aW5nL25neC1zY2FubmVyJywgJ0NhblxcJ3QgYXNrIHBlcm1pc3Npb24sIG5hdmlnYXRvciBpcyBub3QgcHJlc2VudC4nKTtcclxuICAgICAgdGhpcy5zZXRQZXJtaXNzaW9uKG51bGwpO1xyXG4gICAgICByZXR1cm4gdGhpcy5oYXNQZXJtaXNzaW9uO1xyXG4gICAgfVxyXG5cclxuICAgIGlmICghdGhpcy5pc01lZGlhRGV2aWNlc1N1cHBvcnRlZCkge1xyXG4gICAgICBjb25zb2xlLmVycm9yKCdAenhpbmcvbmd4LXNjYW5uZXInLCAnQ2FuXFwndCBnZXQgdXNlciBtZWRpYSwgdGhpcyBpcyBub3Qgc3VwcG9ydGVkLicpO1xyXG4gICAgICB0aGlzLnNldFBlcm1pc3Npb24obnVsbCk7XHJcbiAgICAgIHJldHVybiB0aGlzLmhhc1Blcm1pc3Npb247XHJcbiAgICB9XHJcblxyXG4gICAgbGV0IHN0cmVhbTogTWVkaWFTdHJlYW07XHJcbiAgICBsZXQgcGVybWlzc2lvbjogYm9vbGVhbjtcclxuXHJcbiAgICB0cnkge1xyXG4gICAgICAvLyBXaWxsIHRyeSB0byBhc2sgZm9yIHBlcm1pc3Npb25cclxuICAgICAgc3RyZWFtID0gYXdhaXQgdGhpcy5nZXRBbnlWaWRlb0RldmljZSgpO1xyXG4gICAgICBwZXJtaXNzaW9uID0gISFzdHJlYW07XHJcbiAgICB9IGNhdGNoIChlcnIpIHtcclxuICAgICAgcmV0dXJuIHRoaXMuaGFuZGxlUGVybWlzc2lvbkV4Y2VwdGlvbihlcnIpO1xyXG4gICAgfSBmaW5hbGx5IHtcclxuICAgICAgdGhpcy50ZXJtaW5hdGVTdHJlYW0oc3RyZWFtKTtcclxuICAgIH1cclxuXHJcbiAgICB0aGlzLnNldFBlcm1pc3Npb24ocGVybWlzc2lvbik7XHJcblxyXG4gICAgLy8gUmV0dXJucyB0aGUgcGVybWlzc2lvblxyXG4gICAgcmV0dXJuIHBlcm1pc3Npb247XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKlxyXG4gICAqL1xyXG4gIGdldEFueVZpZGVvRGV2aWNlKCk6IFByb21pc2U8TWVkaWFTdHJlYW0+IHtcclxuICAgIHJldHVybiBuYXZpZ2F0b3IubWVkaWFEZXZpY2VzLmdldFVzZXJNZWRpYSh7IHZpZGVvOiB0cnVlIH0pO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogVGVybWluYXRlcyBhIHN0cmVhbSBhbmQgaXQncyB0cmFja3MuXHJcbiAgICovXHJcbiAgcHJpdmF0ZSB0ZXJtaW5hdGVTdHJlYW0oc3RyZWFtOiBNZWRpYVN0cmVhbSkge1xyXG5cclxuICAgIGlmIChzdHJlYW0pIHtcclxuICAgICAgc3RyZWFtLmdldFRyYWNrcygpLmZvckVhY2godCA9PiB0LnN0b3AoKSk7XHJcbiAgICB9XHJcblxyXG4gICAgc3RyZWFtID0gdW5kZWZpbmVkO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogSW5pdGlhbGl6ZXMgdGhlIGNvbXBvbmVudCB3aXRob3V0IHN0YXJ0aW5nIHRoZSBzY2FubmVyLlxyXG4gICAqL1xyXG4gIHByaXZhdGUgaW5pdEF1dG9zdGFydE9mZigpOiB2b2lkIHtcclxuXHJcbiAgICAvLyBkbyBub3QgYXNrIGZvciBwZXJtaXNzaW9uIHdoZW4gYXV0b3N0YXJ0IGlzIG9mZlxyXG4gICAgdGhpcy5pc0F1dG9zdGFydGluZyA9IG51bGw7XHJcblxyXG4gICAgLy8ganVzdCB1cGRhdGUgZGV2aWNlcyBpbmZvcm1hdGlvblxyXG4gICAgdGhpcy51cGRhdGVWaWRlb0lucHV0RGV2aWNlcygpO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogSW5pdGlhbGl6ZXMgdGhlIGNvbXBvbmVudCBhbmQgc3RhcnRzIHRoZSBzY2FubmVyLlxyXG4gICAqIFBlcm1pc3Npb25zIGFyZSBhc2tlZCB0byBhY2NvbXBsaXNoIHRoYXQuXHJcbiAgICovXHJcbiAgcHJpdmF0ZSBhc3luYyBpbml0QXV0b3N0YXJ0T24oKTogUHJvbWlzZTx2b2lkPiB7XHJcblxyXG4gICAgdGhpcy5pc0F1dG9zdGFydGluZyA9IHRydWU7XHJcblxyXG4gICAgbGV0IGhhc1Blcm1pc3Npb246IGJvb2xlYW47XHJcblxyXG4gICAgdHJ5IHtcclxuICAgICAgLy8gQXNrcyBmb3IgcGVybWlzc2lvbiBiZWZvcmUgZW51bWVyYXRpbmcgZGV2aWNlcyBzbyBpdCBjYW4gZ2V0IGFsbCB0aGUgZGV2aWNlJ3MgaW5mb1xyXG4gICAgICBoYXNQZXJtaXNzaW9uID0gYXdhaXQgdGhpcy5hc2tGb3JQZXJtaXNzaW9uKCk7XHJcbiAgICB9IGNhdGNoIChlKSB7XHJcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ0V4Y2VwdGlvbiBvY2N1cnJlZCB3aGlsZSBhc2tpbmcgZm9yIHBlcm1pc3Npb246JywgZSk7XHJcbiAgICAgIHJldHVybjtcclxuICAgIH1cclxuXHJcbiAgICAvLyBmcm9tIHRoaXMgcG9pbnQsIHRoaW5ncyBnb25uYSBuZWVkIHBlcm1pc3Npb25zXHJcbiAgICBpZiAoaGFzUGVybWlzc2lvbikge1xyXG4gICAgICBjb25zdCBkZXZpY2VzID0gYXdhaXQgdGhpcy51cGRhdGVWaWRlb0lucHV0RGV2aWNlcygpO1xyXG4gICAgICB0aGlzLmF1dG9zdGFydFNjYW5uZXIoWy4uLmRldmljZXNdKTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIENoZWNrcyBpZiB0aGUgZ2l2ZW4gZGV2aWNlIGlzIHRoZSBjdXJyZW50IGRlZmluZWQgb25lLlxyXG4gICAqL1xyXG4gIGlzQ3VycmVudERldmljZShkZXZpY2U6IE1lZGlhRGV2aWNlSW5mbykge1xyXG4gICAgcmV0dXJuIHRoaXMuZGV2aWNlICYmIGRldmljZSAmJiBkZXZpY2UuZGV2aWNlSWQgPT09IHRoaXMuZGV2aWNlLmRldmljZUlkO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogRXhlY3V0ZWQgYWZ0ZXIgdGhlIHZpZXcgaW5pdGlhbGl6YXRpb24uXHJcbiAgICovXHJcbiAgbmdBZnRlclZpZXdJbml0KCk6IHZvaWQge1xyXG5cclxuICAgIC8vIG1ha2VzIHRvcmNoIGF2YWlsYWJpbGl0eSBpbmZvcm1hdGlvbiBhdmFpbGFibGUgdG8gdXNlclxyXG4gICAgdGhpcy5nZXRDb2RlUmVhZGVyKCkuaXNUb3JjaEF2YWlsYWJsZS5zdWJzY3JpYmUoeCA9PiB0aGlzLnRvcmNoQ29tcGF0aWJsZS5lbWl0KHgpKTtcclxuXHJcbiAgICBpZiAoIXRoaXMuYXV0b3N0YXJ0KSB7XHJcbiAgICAgIGNvbnNvbGUud2FybignTmV3IGZlYXR1cmUgXFwnYXV0b3N0YXJ0XFwnIGRpc2FibGVkLCBiZSBjYXJlZnVsLiBQZXJtaXNzaW9ucyBhbmQgZGV2aWNlcyByZWNvdmVyeSBoYXMgdG8gYmUgcnVuIG1hbnVhbGx5LicpO1xyXG5cclxuICAgICAgLy8gZG9lcyB0aGUgbmVjZXNzYXJ5IGNvbmZpZ3VyYXRpb24gd2l0aG91dCBhdXRvc3RhcnRpbmdcclxuICAgICAgdGhpcy5pbml0QXV0b3N0YXJ0T2ZmKCk7XHJcblxyXG4gICAgICByZXR1cm47XHJcbiAgICB9XHJcblxyXG4gICAgLy8gY29uZmlndXJhdGVzIHRoZSBjb21wb25lbnQgYW5kIHN0YXJ0cyB0aGUgc2Nhbm5lclxyXG4gICAgdGhpcy5pbml0QXV0b3N0YXJ0T24oKTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEV4ZWN1dGVzIHNvbWUgYWN0aW9ucyBiZWZvcmUgZGVzdHJveSB0aGUgY29tcG9uZW50LlxyXG4gICAqL1xyXG4gIG5nT25EZXN0cm95KCk6IHZvaWQge1xyXG4gICAgdGhpcy5yZXNldCgpO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogU3RvcHMgb2xkIGBjb2RlUmVhZGVyYCBhbmQgc3RhcnRzIHNjYW5uaW5nIGluIGEgbmV3IG9uZS5cclxuICAgKi9cclxuICByZXN0YXJ0KCk6IHZvaWQge1xyXG5cclxuICAgIGNvbnN0IHByZXZEZXZpY2UgPSB0aGlzLl9yZXNldCgpO1xyXG5cclxuICAgIGlmICghcHJldkRldmljZSkge1xyXG4gICAgICByZXR1cm47XHJcbiAgICB9XHJcblxyXG4gICAgLy8gQG5vdGUgYXBlbmFzIG5lY2Vzc2FyaW8gcG9yIGVucXVhbnRvIGNhdXNhIGRhIFRvcmNoXHJcbiAgICB0aGlzLl9jb2RlUmVhZGVyID0gdW5kZWZpbmVkO1xyXG4gICAgdGhpcy5kZXZpY2UgPSBwcmV2RGV2aWNlO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogRGlzY292ZXJzIGFuZCB1cGRhdGVzIGtub3duIHZpZGVvIGlucHV0IGRldmljZXMuXHJcbiAgICovXHJcbiAgYXN5bmMgdXBkYXRlVmlkZW9JbnB1dERldmljZXMoKTogUHJvbWlzZTxNZWRpYURldmljZUluZm9bXT4ge1xyXG5cclxuICAgIC8vIHBlcm1pc3Npb25zIGFyZW4ndCBuZWVkZWQgdG8gZ2V0IGRldmljZXMsIGJ1dCB0byBhY2Nlc3MgdGhlbSBhbmQgdGhlaXIgaW5mb1xyXG4gICAgY29uc3QgZGV2aWNlcyA9IGF3YWl0IHRoaXMuZ2V0Q29kZVJlYWRlcigpLmxpc3RWaWRlb0lucHV0RGV2aWNlcygpIHx8IFtdO1xyXG4gICAgY29uc3QgaGFzRGV2aWNlcyA9IGRldmljZXMgJiYgZGV2aWNlcy5sZW5ndGggPiAwO1xyXG5cclxuICAgIC8vIHN0b3JlcyBkaXNjb3ZlcmVkIGRldmljZXMgYW5kIHVwZGF0ZXMgaW5mb3JtYXRpb25cclxuICAgIHRoaXMuaGFzRGV2aWNlcy5uZXh0KGhhc0RldmljZXMpO1xyXG4gICAgdGhpcy5jYW1lcmFzRm91bmQubmV4dChbLi4uZGV2aWNlc10pO1xyXG5cclxuICAgIGlmICghaGFzRGV2aWNlcykge1xyXG4gICAgICB0aGlzLmNhbWVyYXNOb3RGb3VuZC5uZXh0KCk7XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIGRldmljZXM7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBTdGFydHMgdGhlIHNjYW5uZXIgd2l0aCB0aGUgYmFjayBjYW1lcmEgb3RoZXJ3aXNlIHRha2UgdGhlIGxhc3RcclxuICAgKiBhdmFpbGFibGUgZGV2aWNlLlxyXG4gICAqL1xyXG4gIHByaXZhdGUgYXV0b3N0YXJ0U2Nhbm5lcihkZXZpY2VzOiBNZWRpYURldmljZUluZm9bXSkge1xyXG5cclxuICAgIGNvbnN0IG1hdGNoZXIgPSAoeyBsYWJlbCB9KSA9PiAvYmFja3x0csOhc3xyZWFyfHRyYXNlaXJhfGVudmlyb25tZW50fGFtYmllbnRlL2dpLnRlc3QobGFiZWwpO1xyXG5cclxuICAgIC8vIHNlbGVjdCB0aGUgcmVhciBjYW1lcmEgYnkgZGVmYXVsdCwgb3RoZXJ3aXNlIHRha2UgdGhlIGxhc3QgY2FtZXJhLlxyXG4gICAgY29uc3QgZGV2aWNlID0gZGV2aWNlcy5maW5kKG1hdGNoZXIpIHx8IGRldmljZXMucG9wKCk7XHJcblxyXG4gICAgaWYgKCFkZXZpY2UpIHtcclxuICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbXBvc3NpYmxlIHRvIGF1dG9zdGFydCwgbm8gaW5wdXQgZGV2aWNlcyBhdmFpbGFibGUuJyk7XHJcbiAgICB9XHJcblxyXG4gICAgdGhpcy5kZXZpY2UgPSBkZXZpY2U7XHJcbiAgICAvLyBAbm90ZSB3aGVuIGxpc3RlbmluZyB0byB0aGlzIGNoYW5nZSwgY2FsbGJhY2sgY29kZSB3aWxsIHNvbWV0aW1lcyBydW4gYmVmb3JlIHRoZSBwcmV2aW91cyBsaW5lLlxyXG4gICAgdGhpcy5kZXZpY2VDaGFuZ2UuZW1pdChkZXZpY2UpO1xyXG5cclxuICAgIHRoaXMuaXNBdXRvc3RhcnRpbmcgPSBmYWxzZTtcclxuICAgIHRoaXMuYXV0b3N0YXJ0ZWQubmV4dCgpO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogRGlzcGF0Y2hlcyB0aGUgc2NhbiBzdWNjZXNzIGV2ZW50LlxyXG4gICAqXHJcbiAgICogQHBhcmFtIHJlc3VsdCB0aGUgc2NhbiByZXN1bHQuXHJcbiAgICovXHJcbiAgcHJpdmF0ZSBkaXNwYXRjaFNjYW5TdWNjZXNzKHJlc3VsdDogUmVzdWx0KTogdm9pZCB7XHJcbiAgICB0aGlzLnNjYW5TdWNjZXNzLm5leHQocmVzdWx0LmdldFRleHQoKSk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBEaXNwYXRjaGVzIHRoZSBzY2FuIGZhaWx1cmUgZXZlbnQuXHJcbiAgICovXHJcbiAgcHJpdmF0ZSBkaXNwYXRjaFNjYW5GYWlsdXJlKHJlYXNvbj86IEV4Y2VwdGlvbik6IHZvaWQge1xyXG4gICAgdGhpcy5zY2FuRmFpbHVyZS5uZXh0KHJlYXNvbik7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBEaXNwYXRjaGVzIHRoZSBzY2FuIGVycm9yIGV2ZW50LlxyXG4gICAqXHJcbiAgICogQHBhcmFtIGVycm9yIHRoZSBlcnJvciB0aGluZy5cclxuICAgKi9cclxuICBwcml2YXRlIGRpc3BhdGNoU2NhbkVycm9yKGVycm9yOiBhbnkpOiB2b2lkIHtcclxuICAgIHRoaXMuc2NhbkVycm9yLm5leHQoZXJyb3IpO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogRGlzcGF0Y2hlcyB0aGUgc2NhbiBldmVudC5cclxuICAgKlxyXG4gICAqIEBwYXJhbSByZXN1bHQgdGhlIHNjYW4gcmVzdWx0LlxyXG4gICAqL1xyXG4gIHByaXZhdGUgZGlzcGF0Y2hTY2FuQ29tcGxldGUocmVzdWx0OiBSZXN1bHQpOiB2b2lkIHtcclxuICAgIHRoaXMuc2NhbkNvbXBsZXRlLm5leHQocmVzdWx0KTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFJldHVybnMgdGhlIGZpbHRlcmVkIHBlcm1pc3Npb24uXHJcbiAgICovXHJcbiAgcHJpdmF0ZSBoYW5kbGVQZXJtaXNzaW9uRXhjZXB0aW9uKGVycjogRE9NRXhjZXB0aW9uKTogYm9vbGVhbiB7XHJcblxyXG4gICAgLy8gZmFpbGVkIHRvIGdyYW50IHBlcm1pc3Npb24gdG8gdmlkZW8gaW5wdXRcclxuICAgIGNvbnNvbGUuZXJyb3IoJ0B6eGluZy9uZ3gtc2Nhbm5lcicsICdFcnJvciB3aGVuIGFza2luZyBmb3IgcGVybWlzc2lvbi4nLCBlcnIpO1xyXG5cclxuICAgIGxldCBwZXJtaXNzaW9uOiBib29sZWFuO1xyXG5cclxuICAgIHN3aXRjaCAoZXJyLm5hbWUpIHtcclxuXHJcbiAgICAgIC8vIHVzdWFsbHkgY2F1c2VkIGJ5IG5vdCBzZWN1cmUgb3JpZ2luc1xyXG4gICAgICBjYXNlICdOb3RTdXBwb3J0ZWRFcnJvcic6XHJcbiAgICAgICAgY29uc29sZS53YXJuKCdAenhpbmcvbmd4LXNjYW5uZXInLCBlcnIubWVzc2FnZSk7XHJcbiAgICAgICAgLy8gY291bGQgbm90IGNsYWltXHJcbiAgICAgICAgcGVybWlzc2lvbiA9IG51bGw7XHJcbiAgICAgICAgLy8gY2FuJ3QgY2hlY2sgZGV2aWNlc1xyXG4gICAgICAgIHRoaXMuaGFzRGV2aWNlcy5uZXh0KG51bGwpO1xyXG4gICAgICAgIGJyZWFrO1xyXG5cclxuICAgICAgLy8gdXNlciBkZW5pZWQgcGVybWlzc2lvblxyXG4gICAgICBjYXNlICdOb3RBbGxvd2VkRXJyb3InOlxyXG4gICAgICAgIGNvbnNvbGUud2FybignQHp4aW5nL25neC1zY2FubmVyJywgZXJyLm1lc3NhZ2UpO1xyXG4gICAgICAgIC8vIGNsYWltZWQgYW5kIGRlbmllZCBwZXJtaXNzaW9uXHJcbiAgICAgICAgcGVybWlzc2lvbiA9IGZhbHNlO1xyXG4gICAgICAgIC8vIHRoaXMgbWVhbnMgdGhhdCBpbnB1dCBkZXZpY2VzIGV4aXN0c1xyXG4gICAgICAgIHRoaXMuaGFzRGV2aWNlcy5uZXh0KHRydWUpO1xyXG4gICAgICAgIGJyZWFrO1xyXG5cclxuICAgICAgLy8gdGhlIGRldmljZSBoYXMgbm8gYXR0YWNoZWQgaW5wdXQgZGV2aWNlc1xyXG4gICAgICBjYXNlICdOb3RGb3VuZEVycm9yJzpcclxuICAgICAgICBjb25zb2xlLndhcm4oJ0B6eGluZy9uZ3gtc2Nhbm5lcicsIGVyci5tZXNzYWdlKTtcclxuICAgICAgICAvLyBubyBwZXJtaXNzaW9ucyBjbGFpbWVkXHJcbiAgICAgICAgcGVybWlzc2lvbiA9IG51bGw7XHJcbiAgICAgICAgLy8gYmVjYXVzZSB0aGVyZSB3YXMgbm8gZGV2aWNlc1xyXG4gICAgICAgIHRoaXMuaGFzRGV2aWNlcy5uZXh0KGZhbHNlKTtcclxuICAgICAgICAvLyB0ZWxscyB0aGUgbGlzdGVuZXIgYWJvdXQgdGhlIGVycm9yXHJcbiAgICAgICAgdGhpcy5jYW1lcmFzTm90Rm91bmQubmV4dChlcnIpO1xyXG4gICAgICAgIGJyZWFrO1xyXG5cclxuICAgICAgY2FzZSAnTm90UmVhZGFibGVFcnJvcic6XHJcbiAgICAgICAgY29uc29sZS53YXJuKCdAenhpbmcvbmd4LXNjYW5uZXInLCAnQ291bGRuXFwndCByZWFkIHRoZSBkZXZpY2UocylcXCdzIHN0cmVhbSwgaXRcXCdzIHByb2JhYmx5IGluIHVzZSBieSBhbm90aGVyIGFwcC4nKTtcclxuICAgICAgICAvLyBubyBwZXJtaXNzaW9ucyBjbGFpbWVkXHJcbiAgICAgICAgcGVybWlzc2lvbiA9IG51bGw7XHJcbiAgICAgICAgLy8gdGhlcmUgYXJlIGRldmljZXMsIHdoaWNoIEkgY291bGRuJ3QgdXNlXHJcbiAgICAgICAgdGhpcy5oYXNEZXZpY2VzLm5leHQoZmFsc2UpO1xyXG4gICAgICAgIC8vIHRlbGxzIHRoZSBsaXN0ZW5lciBhYm91dCB0aGUgZXJyb3JcclxuICAgICAgICB0aGlzLmNhbWVyYXNOb3RGb3VuZC5uZXh0KGVycik7XHJcbiAgICAgICAgYnJlYWs7XHJcblxyXG4gICAgICBkZWZhdWx0OlxyXG4gICAgICAgIGNvbnNvbGUud2FybignQHp4aW5nL25neC1zY2FubmVyJywgJ0kgd2FzIG5vdCBhYmxlIHRvIGRlZmluZSBpZiBJIGhhdmUgcGVybWlzc2lvbnMgZm9yIGNhbWVyYSBvciBub3QuJywgZXJyKTtcclxuICAgICAgICAvLyB1bmtub3duXHJcbiAgICAgICAgcGVybWlzc2lvbiA9IG51bGw7XHJcbiAgICAgICAgLy8gdGhpcy5oYXNEZXZpY2VzLm5leHQodW5kZWZpbmVkO1xyXG4gICAgICAgIGJyZWFrO1xyXG5cclxuICAgIH1cclxuXHJcbiAgICB0aGlzLnNldFBlcm1pc3Npb24ocGVybWlzc2lvbik7XHJcblxyXG4gICAgLy8gdGVsbHMgdGhlIGxpc3RlbmVyIGFib3V0IHRoZSBlcnJvclxyXG4gICAgdGhpcy5wZXJtaXNzaW9uUmVzcG9uc2UuZXJyb3IoZXJyKTtcclxuXHJcbiAgICByZXR1cm4gcGVybWlzc2lvbjtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFJldHVybnMgYSB2YWxpZCBCYXJjb2RlRm9ybWF0IG9yIGZhaWxzLlxyXG4gICAqL1xyXG4gIHByaXZhdGUgZ2V0QmFyY29kZUZvcm1hdE9yRmFpbChmb3JtYXQ6IHN0cmluZyB8IEJhcmNvZGVGb3JtYXQpOiBCYXJjb2RlRm9ybWF0IHtcclxuICAgIHJldHVybiB0eXBlb2YgZm9ybWF0ID09PSAnc3RyaW5nJ1xyXG4gICAgICA/IEJhcmNvZGVGb3JtYXRbZm9ybWF0LnRyaW0oKS50b1VwcGVyQ2FzZSgpXVxyXG4gICAgICA6IGZvcm1hdDtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFJldG9ybmEgdW0gY29kZSByZWFkZXIsIGNyaWEgdW0gc2UgbmVuaHVtZSBleGlzdGUuXHJcbiAgICovXHJcbiAgcHJpdmF0ZSBnZXRDb2RlUmVhZGVyKCk6IEJyb3dzZXJNdWx0aUZvcm1hdENvbnRpbnVvdXNSZWFkZXIge1xyXG5cclxuICAgIGlmICghdGhpcy5fY29kZVJlYWRlcikge1xyXG4gICAgICB0aGlzLl9jb2RlUmVhZGVyID0gbmV3IEJyb3dzZXJNdWx0aUZvcm1hdENvbnRpbnVvdXNSZWFkZXIodGhpcy5oaW50cywgdGhpcy50aW1lQmV0d2VlblNjYW5zKTtcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gdGhpcy5fY29kZVJlYWRlcjtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFN0YXJ0cyB0aGUgY29udGludW91cyBzY2FubmluZyBmb3IgdGhlIGdpdmVuIGRldmljZS5cclxuICAgKlxyXG4gICAqIEBwYXJhbSBkZXZpY2VJZCBUaGUgZGV2aWNlSWQgZnJvbSB0aGUgZGV2aWNlLlxyXG4gICAqL1xyXG4gIHByaXZhdGUgc2NhbkZyb21EZXZpY2UoZGV2aWNlSWQ6IHN0cmluZyk6IHZvaWQge1xyXG5cclxuICAgIGNvbnN0IHZpZGVvRWxlbWVudCA9IHRoaXMucHJldmlld0VsZW1SZWYubmF0aXZlRWxlbWVudDtcclxuXHJcbiAgICBjb25zdCBjb2RlUmVhZGVyID0gdGhpcy5nZXRDb2RlUmVhZGVyKCk7XHJcblxyXG4gICAgY29uc3QgZGVjb2RpbmdTdHJlYW0gPSBjb2RlUmVhZGVyLmNvbnRpbnVvdXNEZWNvZGVGcm9tSW5wdXRWaWRlb0RldmljZShkZXZpY2VJZCwgdmlkZW9FbGVtZW50KTtcclxuXHJcbiAgICBpZiAoIWRlY29kaW5nU3RyZWFtKSB7XHJcbiAgICAgIHRocm93IG5ldyBFcnJvcignVW5kZWZpbmVkIGRlY29kaW5nIHN0cmVhbSwgYWJvcnRpbmcuJyk7XHJcbiAgICB9XHJcblxyXG4gICAgY29uc3QgbmV4dCA9ICh4OiBSZXN1bHRBbmRFcnJvcikgPT4gdGhpcy5fb25EZWNvZGVSZXN1bHQoeC5yZXN1bHQsIHguZXJyb3IpO1xyXG4gICAgY29uc3QgZXJyb3IgPSAoZXJyOiBhbnkpID0+IHRoaXMuX29uRGVjb2RlRXJyb3IoZXJyKTtcclxuICAgIGNvbnN0IGNvbXBsZXRlID0gKCkgPT4geyB0aGlzLnJlc2V0KCk7IGNvbnNvbGUubG9nKCdjb21wbGV0ZWQnKTsgfTtcclxuXHJcbiAgICBkZWNvZGluZ1N0cmVhbS5zdWJzY3JpYmUobmV4dCwgZXJyb3IsIGNvbXBsZXRlKTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEhhbmRsZXMgZGVjb2RlIGVycm9ycy5cclxuICAgKi9cclxuICBwcml2YXRlIF9vbkRlY29kZUVycm9yKGVycjogYW55KSB7XHJcbiAgICB0aGlzLmRpc3BhdGNoU2NhbkVycm9yKGVycik7XHJcbiAgICB0aGlzLnJlc2V0KCk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBIYW5kbGVzIGRlY29kZSByZXN1bHRzLlxyXG4gICAqL1xyXG4gIHByaXZhdGUgX29uRGVjb2RlUmVzdWx0KHJlc3VsdDogUmVzdWx0LCBlcnJvcjogRXhjZXB0aW9uKTogdm9pZCB7XHJcblxyXG4gICAgaWYgKHJlc3VsdCkge1xyXG4gICAgICB0aGlzLmRpc3BhdGNoU2NhblN1Y2Nlc3MocmVzdWx0KTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIHRoaXMuZGlzcGF0Y2hTY2FuRmFpbHVyZShlcnJvcik7XHJcbiAgICB9XHJcblxyXG4gICAgdGhpcy5kaXNwYXRjaFNjYW5Db21wbGV0ZShyZXN1bHQpO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogU3RvcHMgdGhlIGNvZGUgcmVhZGVyIGFuZCByZXR1cm5zIHRoZSBwcmV2aW91cyBzZWxlY3RlZCBkZXZpY2UuXHJcbiAgICovXHJcbiAgcHJpdmF0ZSBfcmVzZXQoKTogTWVkaWFEZXZpY2VJbmZvIHtcclxuXHJcbiAgICBpZiAoIXRoaXMuX2NvZGVSZWFkZXIpIHtcclxuICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG5cclxuICAgIGNvbnN0IGRldmljZSA9IHRoaXMuZGV2aWNlO1xyXG4gICAgLy8gZG8gbm90IHNldCB0aGlzLmRldmljZSBpbnNpZGUgdGhpcyBtZXRob2QsIGl0IHdvdWxkIGNyZWF0ZSBhIHJlY3Vyc2l2ZSBsb29wXHJcbiAgICB0aGlzLl9kZXZpY2UgPSBudWxsO1xyXG5cclxuICAgIHRoaXMuX2NvZGVSZWFkZXIucmVzZXQoKTtcclxuXHJcbiAgICByZXR1cm4gZGV2aWNlO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogUmVzZXRzIHRoZSBzY2FubmVyIGFuZCBlbWl0cyBkZXZpY2UgY2hhbmdlLlxyXG4gICAqL1xyXG4gIHB1YmxpYyByZXNldCgpOiB2b2lkIHtcclxuICAgIHRoaXMuX3Jlc2V0KCk7XHJcbiAgICB0aGlzLmRldmljZUNoYW5nZS5lbWl0KG51bGwpO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogU2V0cyB0aGUgcGVybWlzc2lvbiB2YWx1ZSBhbmQgZW1taXRzIHRoZSBldmVudC5cclxuICAgKi9cclxuICBwcml2YXRlIHNldFBlcm1pc3Npb24oaGFzUGVybWlzc2lvbjogYm9vbGVhbiB8IG51bGwpOiB2b2lkIHtcclxuICAgIHRoaXMuaGFzUGVybWlzc2lvbiA9IGhhc1Blcm1pc3Npb247XHJcbiAgICB0aGlzLnBlcm1pc3Npb25SZXNwb25zZS5uZXh0KGhhc1Blcm1pc3Npb24pO1xyXG4gIH1cclxuXHJcbn1cclxuIl19